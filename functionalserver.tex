\section{Functional servers}

\theoremstyle{definition}
\newtheorem{exmp}{Example}[section]
\subsection{RESTful servers}


Servers are applications that provide functionality for other programs or
devices, called clients. Services are servers that allow sharing data or
resources among clients or to perform a computation.

REST (Representational State Transfer) is a software architecture style that is
used to construct web services. A so called RESTful web service allow requesting
systems to access and manipulate textual representations of web services by
using a set of stateless operations. The architectual constraints of REST are as
follows:

\begin{description}
\item[ Client - Server Architecture ] Separate the concerns between user
interface concerns and data storage concerns.
\item[Statelessness] Each request contains all the information neccessary to
perform a request. State can be handled by cookies on the user side or by using
databases. The server itself contains no state.
\item[Cacheability] As on the World Wide Web, clients and intermediaries can
cache responses. Responses must therefore, implicitly or explicitly, define
themselves as cacheable or not to prevent clients from getting stale or
inappropriate data in response to further requests. Well-managed caching
partially or completely eliminates some clientâ€“server interactions, further
improving scalability and performance. 
\item[Layered system] A client can not tell if it is connected to an end server
or some intermeditary server. 
\item[Code on demand] Servers can send functionality of a client via exectuable
code such as javascript. This can be used to send the frontend for example.
\item[Uniform interface] The interface of a RESTful server consists of four
components. The request must specify how it would like the resource to be
represented; that can for example be as JSON, XML or HTTP which are not the
servers internal representation. Servers internal representation is therefore
separated. When the client holds a representation of the resource and metadata
it has enough information to manipulate or delete the resource. Also the REST
server has to, in it's response, specify how the representation for the
resource. This is done using Media type. Some common media types are JSON, HTML
and XML.
\end{description}

A typical HTTP request on a restful server consists of one of the  verbs: GET,
POST, DELETE, PATCH and PUT. They are used as follows:

\begin{description}
\item[GET] Fetches a resource from the server. Does not perform any mutation. 
\item[POST] Update or modify a resource.
\item[PUT] Modify or create a resource.
\item[DELETE] Remove a resource from the server.
\item[PATCH] Changes a resource.
\end{description}

A request will specify a header ``Content-Type'' which contains the media
representation of the request content. For example if the new resource is
represented as Json then content-type will be ``application/json''. It also
specifies a header ``Accept'' which informs which type of representation it
would like to have, for example Html or Json. 

A request will also contain a route for the resource it is requesting. These
requests can also have optional parameters called query parameters. In the
request route:

\begin{lstlisting}
/api/books?author=Mary&published=1995
\end{lstlisting}

the $?$ informs that the request contains query parameters which are optional.
In the example above it specfies that the request wants to access the books
resource with the parameters author as Mary and published as 1995.


When a request has been done the server responds with a status code that
explains the result of the request. The full list of status codes and their
descriptions can be found here:
\url{https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}

\subsection{Implementation concerns for REST apis}

A REST api has to concern themselves with the following:

\begin{itemize}
\item Ensure that the response has the correct status code.
\item Ensure that the correct representation is sent to the client.
\item Parse the route and extract it's parameters. 
\item Parse the query and extract it's parameters.
\item Handle errors if the route or query are badly formatted.
\item Generate the correct response body containing all the resources needed.
\end{itemize}

Every type of error has a specific status code, these need to be set correctly.

\section{Architect of a sustainable server} 

\section{Modeling a server in functional programming}

\subsection{Constraints for good architecture}

\subsection{Look}

\subsection{Implementation}

\subsection{Definitions}

\subsubsection{Verbs and Media types}

A verb is either get, post, put, patch or delete, represented as a sum type $type Verb = Get\ |\ Post\ |\ Put\ |\ Patch\ |\
Delete$. Content types are harder to represent as a sum type due to there being
so many and are thus represented as a string instead.

\subsubsection{Request and Response}

A Request is a product type consisting of a url, queries, accept header (Media),
headers (a list of string tuples), accept media, verb, encodded body and an
encoding. The correct encoder can be deduced from the accept header.

A Response is a product type consisting of a body, status code, content type
Media, headers (a list of string tuples) and an \textit{encoder for the body}.
An encoded response instead contains an encoded body. These are separated
because the body will be constructed separately from the encoder.

A server of parameter b is a type that takes a request and transforms it into a
response of parameter b. I.E.  $server : Request\rightarrow Response\ encoded$.
A $Response\ b$ is a contravariant product type consisting a status code, a set
of headers, a content type, a function $body: a\rightarrow encoded$ and
encoding.

\begin{lstlisting}
  type Response a = {
    code: StatusCode,
    headers: Header ,
    contentType: MediaType,
    body: a -> encoded,
    encoding: Encoding.t,
  };
\end{lstlisting}

When constructing a Response a series of computations need to be done. If one of
these fails, due to internal implementation errors or invalid requests there
needs to be an error handling system in place. To account for this, a type
$computation\ a\ b = a \rightarrow Result\ b$, where result is a sum type
$Result\ a = Ok\ a\ |\ Fail\ Code\ Media\ Message$, is introduced. Computation
is also a Monad, meaning that computations can be composed together, where if
one computation should fail it skips executing the rest and returns a failure
containing the correct status code. 


An endpoint is a computation of a $Request$ to a tuple of function handler $h$
and a $Response\ body$. An endpoint $e\ a\ b$ is complete if $e\sim computation\
Request\ (Result\ b, Response\ b)$. For all complete endpoints, there exists a
function $\forall b. part\ b \ b\sim Request \rightarrow (Result\ b, Response\
b)\Rightarrow part\ b\ b \rightarrow server$. This function applies the result
of the handler to the Response encoder to create $Response\ encoded$. Thus to
construct a server from an endpoint, the endpoint must be complete and for all
complete endpoints, handler is $Result\ a$.

Since a computation is a strong profunctor and a monad, non-complete endpoints
can be composed together to produce a complete endpoint. Thus we introduce
combinators as follows.

Extract the encoder from the request and contramap that encoder to the
response: 
\begin{equation}
\begin{split}
    accept & : [Media,a\rightarrow encoded] \\
           & \rightarrow endpoint\ h\ encoded \\ 
           & \rightarrow endpoint\ h\ a \\
\end{split}
\end{equation}

Extract a query parameter and apply that to the handler: 
\begin{equation}
\begin{split}
    query &: parameter\\
          &\rightarrow (value\rightarrow Maybe(a))\\
          & \rightarrow endpoint\ (Maybe(a)\rightarrow h)\ b \\
          &\rightarrow endpoint\ h\ b \\ 
\end{split}
\end{equation}

Depending on the URI of the request, a different endpoint should be 

\begin{itemize}
\item An ordered set of required parameters to execute a handler.
\item An ordered set of optional query parameters to execute a handler.
\item A set of accepted representations for a resource as well as an
accompanying function that encodes the resource to the represenation.
\item A handler to execute, where a handler must take the correct parameters and
return the correct resource.
\item A set of http request methods supported by the endpoint.
\end{itemize}


Each computation in an endpoint will morph the handler or the Response. An
endpoint consists of a composition of parts, where $part\ h\ b = computation\
Request\ (h,Response\ b)$ and $h$ is a handler. A $part$ is \textit{complete} if
$part\sim Request \rightarrow (Result\ b, Response\ b)$.  When a part is
complete it means that all parameters from the request have been extracted and
appended to the handler and the Response has a way to encode the result of the
handler. Thus a function $\forall b. part\ b \ b\sim Request \rightarrow (Result\
b, Response\ b)\Rightarrow part\ b\ b \rightarrow server$ exists.


The body of a response is a function that transforms the resource into it's
requested representation. If the request specifies accept as
\lstinline{application/json} then the body function turns the body into a json
format. 

A $Request$ is a monad that parses the incoming request. It transforms that
into a request handler that then feeds the result into a response. A handle is a
function $a\rightarrow Response\ b$. The extended definition of the server
is then $Server : Request\ a \rightarrow (a \rightarrow Response\ b) \rightarrow
Response\ b$.

\section{Cause, a functional REST framework}

Cause is a high-level web framework that allows writing composable REST
frameworks in Reasonml. In Cause, a REST api is a \textit{specification}, where
the user specifies endpoints. An endpoint in a spec contains the following:
An endpoint is composable, meaning that you can create a \textit{connector
endpoint} which consists of two \textit{subendpoints}. The following operations
exist for endpoints

\begin{description}
\item [oneOf $: list(endpoint)$] Creates a connector endpoint out of a list of
subendpoints.
\item [is $: string \rightarrow endpoint$] Checks that the request contains a
given string in it's path.
\item [int $: endpoint$] Extracts an integer from the request path and feeds it
into the handler.
\item [text $: endpoint$] Extracts a text from the request path and feeds it into
the handler.
\item [contentType $: list(MediaType,a \rightarrow encoded)$] Checks that the
request contains one of the supported media types and sets the appropriate
encoder.
\item [accept $: list(MediaType,encoded \rightarrow a)$] Takes a set of
supported mediatypes and a way to transform the encoded value into the value.
\item [($\rightarrowtail$) $: endpoint \rightarrow endpoint \rightarrow endpoint$] 
An operator for composing endpoints.
\item [get $: handler \rightarrow endpoint \rightarrow endpoint$] Connects an
endpoint to a handler and ensures that endpoint accepts only GET.
\item [delete $: handler \rightarrow endpoint \rightarrow endpoint$] Connects an
endpoint to a handler and ensures that endpoint accepts only DELETE.
\item [put $: handler \rightarrow endpoint \rightarrow endpoint$] Connects an
endpoint to a handler and ensures that endpoint accepts only PUT.
\item [post $: handler \rightarrow endpoint \rightarrow endpoint$] Connects an
endpoint to a handler and ensures that endpoint accepts only POST.
\end{description}

\begin{exmp}
A RESTful api User manages user data for a server at the path \lstinline{/user}.
It has the handlers $getUser: id \rightarrow list(User)$, $postUser : User
\rightarrow result$, $deleteUser : id \rightarrow result$. The user endpoint
then becomes


\begin{lstlisting}[escapeinside={((*}{*))}]
userSpec = is("user") ((*$\rightarrowtail$*)) oneOf(
    [int ((*$\rightarrowtail$*)) contentType([(Json,encodeJson)]) ((*$\rightarrowtail$*)) get(getHandler),
    ,accept([(Json,decodeJson)]) ((*$\rightarrowtail$*)) post(postHandler),
    ,int ((*$\rightarrowtail$*)) delete(deleteHandler),
    ])
\end{lstlisting}
\end{exmp}





