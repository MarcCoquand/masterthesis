\section{Functional servers}

A $server$ is a function of type $Request \rightarrow Response encoded$.
Request is a product of the path, media type, accept header, content type header
and a body. The path needs to be parsed to figure out which endpoint to use.
Based on the accept header and content type header the correct encoders and
decoders also need to be set.

Based on the REST api description outlined in chapter 2, we can define a
\textit{type specification a b} as a GADT which constructs a small DSL for a
REST api. For $specification$ there exists a function $makeServer : \forall a\
a.\ Specification\ a\ a \rightarrow (Request \rightarrow Response encoded)$.
$makeServer$ works as a parser, it extracts the parameters from the request
based on the specification and feeds them into a handler function, which is also
constructed from the specification. Specification encodes the response based on
the request's accept header and the included encoder in the specification.

The same $specification$ value can also be used afterwards to generate
documentation, client functions for generating correct requests.

\theoremstyle{definition}

A verb is either get, post, put, patch or delete, represented as a sum type
$type\ Verb = Get\ |\ Post\ |\ Put\ |\ Patch\ |\
Delete$. Content types are harder to represent as a sum type due to there being
so many and are thus represented as a string instead.

\subsubsection{Request and Response}

A Request is a product type consisting of a url, queries, accept header (Media),
headers (a list of string tuples), accept media, verb, encodded body and an
encoding. The correct encoder can be deduced from the accept header.

A Response is a product type consisting of a body, status code, content type
Media, headers (a list of string tuples) and an \textit{encoder for the body}.
An encoded response instead contains an encoded body. These are separated
because the body will be constructed separately from the encoder.

\begin{lstlisting}
  type Response a = {
    code: StatusCode,
    headers: Header ,
    contentType: MediaType,
    body: a -> encoded,
    encoding: Encoding.t,
  };
\end{lstlisting}

A server of parameter b is a type that takes a request and transforms it into a
response of parameter b. I.E.  $server : Request\rightarrow Response\ encoded$.

Of course, depending on the Request a different Response should be returned. So
we need to introduce a $Router$ that can, depending on the request, give a
different response. 

A Router is a parser that checks the content of the request and then modifies
the response and applies the parameters of the request to a handler. We separate
how the response should be encoded from the handler to ensure inversion of
control. By making the implementation of the handler not depend on it's
environment, we make it possible to test effects (E.G. adding a resource to a
database, doing system calls) separate from the implementation of the
specification. 

In order to do so, we need to create a small language for creating
specifications. This is done by using GADTs. Recall that a GADT is a sum type
where you can specify the return types. So the GADT for a specification becomes
as follows:

\begin{lstlisting}
  type router 'input 'output =
    Top : router ('a, 'a) ('a, 'a)
    Exact : string -> router ('a, 'b) ('a, 'b)
    Custom : (string -> Maybe a) -> router ('a -> 'b, 'c) ('b, 'c)
    Query : string 
            -> (string -> Maybe 'a) 
            -> router (Maybe 'a -> 'b, 'c) ('b, 'c)
    Slash : router ('a, 'b) ('c, 'd) 
            -> router ('c, 'd) ('e, 'f) 
            -> router ('a, 'b) ('e, 'f) 
    Integer : router (int -> 'a, 'b) ('a, 'b)
    Method : HttpMethod -> router ('a, 'b) ('a, 'b)
    Accept : [(MediaType, 'b -> string)] -> router ('a, string) ('a, 'b)
    ContentType : [((MediaType, string -> Maybe 'a)]
                  -> router ('a -> 'b, 'c) ('b, 'c)
    Map : StatusCode 
        -> 'a 
        -> router ('a, string) (Result.t('c), 'c)
        -> router ('(b, string) -> string) (Result (Response.content string))
    OneOf :
          [router ('(b, string) -> string) (Result (Response.content string))]
          -> router ((b, string) -> string) Request;
\end{lstlisting}


This looks complicated, but it essentially describes the operations of a REST
api and routing. Top, Exact, Custom, Integer are used to match that URI is
correct, for example an endpoint \texttt{/user/:id} is created by doing
\texttt{Slash (Exact "user") Integer}. \texttt{Slash} connects operations
together. Afterwards \texttt{Map} is used to map a side effect to the
specification and \texttt{OneOf} is used to take a list of mapped routers and
combine them into one. The infix operator for Slash is \texttt{(>-) = Slash}. So
a valid specification can be \texttt{get = Method GET >- Exact "user" >-
Integer}.

Router is simply an \textit{instructions} for how it wants to be evaluated. That
means it can be used to generate documentation for every endpoint, by
constructing a function \texttt{document : router ((b, string) -> string)
Request -> String}, the REST API library can automatically generate the
documentation for us!

So since a Router is just instructions, we can construct \texttt{evaluate :
router((b, string) -> string) -> (Request -> Response encoded)}, I.E. the router
specification creates a server! This thesis will omit most of the details in
regards to how this is implemented. The only thing to note is that \texttt{Map}
will feed the parameters from the request into a handler $a$. This means that,
for example, a database function which fetches users will automatically not have
to, in any way, concern itself with how that user is then encoded or what status
message to return. This means that the server library \textit{forces} the user
to implement inversion of control, single responsibility principle and interface
segregation principle. It forces inversion of control, because the evaluation of
the specification is not dependent on the handler (an evaluator can just ignore
it). It forces interface segregation interface principle because the handler is
only fed the exact values, nothing more, for it to work and it can not return
more than what the specification specifies that it needs to encode the value.
Lastly it forces single responsibility principle by forcing the user to
construct a separate function for fetching the user.

