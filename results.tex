\chapter{Results}\label{results}

Four interviews were performed and two servers were implemented and analyzed.
The source code for the programs can be found in Appendix~\ref{reasonmlrest} for
the ReasonML implementation and in Appendix~\ref{nodejsrest} for the imperative
implementation, written in Express.  This chapter will present the results of
those interviews and also present an analysis of the server's adherence to SOLID
principles.

\section{Evaluating adherence to SOLID}

Through an expert analysis the adherence to SOLID guidelines in
Section~\ref{evaluatingmaintainability} of the solution in ReasonML can be
analyzed. It is the resulting code of using the library that is analyzed and
not the library itself as the goal is to find if Functional programming
constructs can be used to enforce an idiomatic solution.  The solution was
written by the author in a ``as naive'' approach as possible.  That means that
the author did not consider any design guidelines but created the software in
such a way that it would compile.

\subsubsection{Single Responsibility Principle}

Recall that the Single Responsibility Principle for functional programming
states that all modules should revolve around one type.  The file BookApi.re
contains one product type Book. The modules Encoders and Decoders both use this
type except for one helper function \texttt{int}.  The module Endpoint's
functions all revolve around the type \texttt{route (a)}, which all use book
except the handler \texttt{delete}, which is a helper function for the function
\texttt{router}. Thus the solution follows Single Responsibility Principle.

\subsubsection{Open/Closed Principle}

OCP, as defined in Section~\ref{openclosed}, that the data structures should be
open for extensions without modifying the previous code.  The book API
functionality can be extended with new endpoints without modifying any of the
original code. The router is implemented as a list of endpoints, thus if the
user wants to add a new endpoint it can append new endpoints to the list.
However, it is not possible to extend existing endpoints without modifying the
code.  For example, should the user want to prepend so that each URI starts with
\url{/new} then that is not possible, the existing code has to be modified.

\subsubsection{Liskov Segregation Principle}

Liskov Segregation Principle does not apply to this solution.

\subsubsection{Interface Segregation Principle}

Interface segregation principle states that the cardinality should be as low as
possible.  While it is impossible to force the user to have the lowest
cardinality possible the library encourages usage of the lowest possible
cardinality by feeding the arguments into the handler and stating the return
type. So in the BookApi.re that every $specification$ forces a contract on the
function and states that to work they must take the specified arguments which
it will extract from the request with the parser function. So it means that the
cardinality of the handler must be according to the $specification$.

\subsubsection{Dependency Inversion Principle}

Dependency Inversion Principle is about separating the logic from its
environment.  Since the $specification$ GADT separates the handler from the
specification, it means that should the developer want to change the handler
they can change the argument at one spot. If the developer should want to change
the REST API library, handlers are separated from the $specfication$. Thus the
developer would not need to change any of the logic of the handlers. Therefore
the code follows the dependency inversion principle.  Also due to its
separation, it means that testing the logic of the API is easier.  

\subsection{Imperative solution}

Since the solution was developed in an untyped language with no force of
structure it makes sense that the SOLID principles will not be followed. However
it is presented below:

\begin{description}
	\item[Single Responsibility Principle] The imperative solution breaks SRP
in all handlers by having functions that both parse the requests and performs
the side effects. Demonstrated in the first handler App.get
	\item[Open/Closed Principle] N/A
	\item[Interface Segregation Principle] N/A
	\item[Dependency Inversion Principle] In the imperative solution, it is 
impossible to test the handler in isolation. All systems need to be emulated
such as database and the router.
	\item[Liskov Segregation Principle] N/A
\end{description}

\section{Interviews}\label{interviews}

With the method outlined in the previous chapter, the interview was performed
on 4 subjects, which is a bit less than the recommended by Norman group of five
subjects due to difficulty finding enough users.~\cite{jakobnielsen} It was
performed through the use of Skype, a communication tool\footnote{Skype's
website: \url{https://www.skype.com}}. The four respondents have graduated
students of the Engineering Interaction Technology and Design program at Ume√•
University. The program is a five-year degree that combines education in
software engineering with studies in design. The questions were originally
asked in Swedish but translated to English by the author. The answers can be
found in Table~\ref{interviewonetwo} and Table~\ref{interviewthreefour}. Below
the questions that were asked are presented once more.

\begin{description}
    \item[Q1] What is your experience with RESTful APIs?
    \item[Q2] What is your experience with Express?
    \item[Q3] What is your experience with ReasonML?
    \item[Q4] After being presented the code API, can you explain what it does?
    \item[Q5] Which media types does the endpoint post accept?
    \item[Q6] What is the URI of DELETE?
    \item[Q7] Which media types representations can the endpoint show?
    \item[Q8] Given a handler putInDatabase, Can you demonstrate how you would
        extend the API and add a new endpoint for a PUT request.
    \item[Q9] Looking at the JavaScript API, can you explain what it does?
    \item[Q10] Which media types does the endpoint get accept?
    \item[Q11] Which content type and accept does post have?
\end{description}


\begin{table}[]
\begin{tabular}{lll}
\hline
\textbf{}                         & \textbf{Person 1}
& \textbf{Person 2}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q1}}  &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Implemented API that should\\
follow REST. I assume its\\ related to CRUD?\end{tabular}}
& \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}A little bit, REST is an API
with\\ endpoints containing method\\ and headers ensuring you\\ get the right
data.\end{tabular}}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q2}}  &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Little bit, it should be \\
Javascript and Ocaml \\ combined.\end{tabular}}
& \multicolumn{1}{l|}{No experience}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q3}}  &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}I've implemented an API in\\
Express\end{tabular}}
& \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}I had a course where I used\\
Express three years ago.\end{tabular}}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q4}}  &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}The title is BookApi.re which\\
describes it quite well. It is\\ a Book API that follows\\ RESTful. It also
manages \\ encoding and decoding.\\ It also checks that the \\ requests are
correctly \\ formatted.\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Encoders and Decoders extract\\
data from the json and\\ I understand the handler\\ functions. \\
However the module Endpoint is unclear.\\ Especially $type\ a.\ route(a)$.\end{tabular}}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q5}}  & \multicolumn{1}{l|}{application json}
& \multicolumn{1}{l|}{Maybe string?}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q6}}  & \multicolumn{1}{l|}{$api/books/:int$}
& \multicolumn{1}{l|}{No clue}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q7}}  & \multicolumn{1}{l|}{application/json}
& \multicolumn{1}{l|}{Content type? Json?}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q8}}  & \multicolumn{1}{l|}{See
Appendix~\ref{putperson1}}
& \multicolumn{1}{l|}{See Appendix~\ref{putperson2}}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q9}}  & \multicolumn{1}{l|}{A book API}
& \multicolumn{1}{l|}{A Book REST API}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q10}} & \multicolumn{1}{l|}{text/plain and
application/json}
& \multicolumn{1}{l|}{text/plain and application/json}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q11}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Content type is json and\\ Accept
might be json?\end{tabular}}
& \multicolumn{1}{l|}{Unsure}
\\ \hline
\end{tabular}
\caption{Raw results interview one and two}
\label{interviewonetwo}
\end{table}

\begin{table}[]
\begin{tabular}{lll}
\hline
\textbf{}                         & \textbf{Person 3}
& \textbf{Person 4}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q1}}  &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}I know what it is. It specifies
\\ how to receive and send \\ information to the client.\end{tabular}}
& \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}It is used for making HTTP \\
requests and setting up a \\ server using simple methods\\ for
changes.\end{tabular}}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q2}}  & \multicolumn{1}{l|}{I have seen it.}
& \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}I have no experience but
heard\\ about it\end{tabular}}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q3}}  &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}It is my go to library for\\
writing servers.\end{tabular}}
& \multicolumn{1}{l|}{I have worked with it}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q4}}  &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Code to encode and decode\\ so
that people can not read the\\ content of the books.\\ \\ Not sure what plain
means in\\ content type.\\ Are modules objects?\end{tabular}} &
\multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}First modules define encoding\\
and decoding json data. \\ \\ Afterwards some helper \\ functions. \\ \\ Lastly
there are endpoints with\\ router defined with different\\ paths and query
parameters.\\ \\ It is a REST API for adding, \\ deleting and modifying
books.\end{tabular}} \\ \hline
\multicolumn{1}{l|}{\textbf{Q5}}  & \multicolumn{1}{l|}{N / A}
& \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}responds with json and \\
accepts plain.\end{tabular}}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q6}}  & \multicolumn{1}{l|}{$/delete$}
& \multicolumn{1}{l|}{$/api/books$.}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q7}}  & \multicolumn{1}{l|}{application/json}
& \multicolumn{1}{l|}{N/A}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q8}}  & \multicolumn{1}{l|}{See
Appendix~\ref{putperson3}}
& \multicolumn{1}{l|}{See Appendix~\ref{putperson4}}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q9}}  & \multicolumn{1}{l|}{A book API to fetch
books}
& \multicolumn{1}{l|}{A Book REST API}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q10}} & \multicolumn{1}{l|}{string}
& \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}It can recieve text/plain and
\\ application/json but unsure \\ what it can send\end{tabular}}
\\ \hline
\multicolumn{1}{l|}{\textbf{Q11}} & \multicolumn{1}{l|}{Application/json}
& \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Application/json but not
specified\\ what it accepts, assume plain/text.\end{tabular}}
\\ \hline
\end{tabular}
\caption{Raw results interview three and four}
\label{interviewthreefour}
\end{table}

\newpage
Person 1 and Person 4 understood correctly what the library does. However all
four subjects where slightly confused as to what encoders and decoders were used
for. Not one of the subjects could correctly guess what the accept and content
types in the Javascript solutions. Q5 for person 3 the question was omitted as
the user could not guess what the code was supposed to do and assumed that it a
system for encrypting books, rendering the question useless.

\section{Summary}\label{resultsummary}

In this chapter we have compared the two servers, one created using imperative
programming, one using functional and evaluated their's adherence to SOLID
principles. Four interviews were conducted on four subjects to establish the
readability of the two solutions. 
