\chapter{Method: Case studies}

In the Chapter~\ref{theory} we defined what programming paradigms are and how we
can evaluate their testability and their cognitive complexity using Cyclomatic
complexity and Cognitive dimensions. In Section~\ref{measuretestability} we also
explained how Cyclomatic complexity and Cognitive dimensions is tied to the
maintainability and testability of software. The aim of this study is to find if
the functional paradigm or the OOP paradigm is more maintainable than the other
and in which situations. This study will compare the cyclomatic complexity and
cognitive complexity by looking at three different cases. If we find that the
Cyclomatic complexity is lower in one of the paradigms or the other, we can
conclude that the amount of tests write for full branch coverage will be lower
for that paradigm than the other. By evaluating the paradigms using cognitive
dimensions we can find if one paradigm is easier to maintain for the developer.
The cases were chosen based on how they are often subproblems in bigger
applications. The solutions for functional programming will be implemented using
Haskell and for OOP we will use Java. 

Java is a programming language that is class-based and object-oriented. The aim
of the language is that you should be able to write the code and run it
anywhere.~\cite{java} Haskell is a purely functional programming language, it
also features lazy evaluation which allows you to compose functions easier. For
example, the function $three = take\; 3 \, \circ \, cycle\; 5$, where cycle is a
function that generates an infinitely long list consisting of a number, would
only compute the first three values, I.E. $[5,5,5]$, of the infinite list.  In a
non-lazy program it would never evaluate as $cycle$ would run
forever.~\cite{haskell} The reason these languages where chosen is because of
the authors familiarity with those languages.

\subsubsection*{Simplified chess game}

Chess is a famous game and in this report it is assumed that the reader know how
it works.\footnote{Rules of chess: \url{en.wikipedia.org/wiki/Rules_of_chess}}
Aim is to implement a simplified variant of it. This is not ordinary chess but a
simplified version:

\begin{itemize} 
    \item Only pawns and horses exist.
    \item You win by removing all the other players pieces.
\end{itemize}

The player should be able to do the following:

\begin{itemize} 
    \item List all available moves for a certain chess piece. 
    \item Move the chess piece to a given space
    \item Switch player after move
    \item Get an overview of the board
    \item Get an error when making invalid moves
\end{itemize}

To interact with the game, a user types commands through a command line prompt.
An example of basic interaction with the game is displayed in
Figure~\ref{chessexample}.

\begin{figure}[H]
    \centering
    \begin{lstlisting}
        > list (a,2)
        White pawn at (a,2)
        > move (a,2) (a,3)
        White pawn moved to (a,3)
        > listall
        White pawn at (a,3)
        White pawn at (b,2)
        ...
        White Horse at (a,1)
        ...
        Black pawn at (a,8)
        ...
    \end{lstlisting}
    \label{chessexample}
    \caption{An example of the interaction in the chess game.}
\end{figure}


\subsubsection*{To-do List}

A common task in programming is to create some kind of data store with
information. A to-do list is a minimal example of that. It consists of a list of
items that can be used to remember what to do later. The user should be able to:

\begin{itemize}
    \item Create a new item in the to-do list.
    \item Remove an item from the to-do list.
    \item Mark an item from the to-do list as done.
    \item See all items in the to-do list.
\end{itemize}

The interface to this program will be a text interface, displaying each item in
the todo list. To navigate and mark an item in the list the user presses up and
down and presses \texttt{x} to mark it.

\subsubsection*{Chat-bot engine}

Oftentimes when developing applications we have to deal with complex information
input. One of those cases is when we have chat-bots. Chat-bots are interactive
programs that respond with a text answer to the users input. For this
application we will implement the following:

\begin{itemize}
    \item Interpretor that can handle semi-complex inputs and deal with errors.
    \item Give answers to those inputs in form of text messages.
\end{itemize}

\noindent Once these programs have been constructed then cyclomatic complexity
can be evaluated by summing the cyclomatic complexity of each function. We can
also evaluate the cognitive complexity using the cognitive dimensions framework.
Thus we get can see if smaller subproblems in big applications require more
tests and have a bigger mental complexity depending on the different paradigms.
