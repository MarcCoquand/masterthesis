\chapter{Method: Case studies}

Chapter~\ref{theory} defined what programming paradigms are and how to evaluate
their testability and their cognitive complexity using Cyclomatic complexity and
Cognitive dimensions. Section~\ref{measuretestability} also explained how
Cyclomatic complexity and Cognitive dimensions is tied to the maintainability
and testability of software. The aim of this study is to find if the functional
paradigm or the OOP paradigm is more maintainable than the other and in which
situations. This study will compare the cyclomatic complexity and cognitive
complexity by looking at three different cases. If the Cyclomatic complexity is
lower in one of the paradigms or the other, then the amount of tests write for
full branch coverage will be lower for that paradigm than the other.
Evaluating the paradigms using cognitive dimensions finds if one paradigm
is easier to maintain for the developer.  The cases were chosen based on how
they are often subproblems in bigger applications. The solutions for functional
programming will be implemented using Haskell and for OOP Java will be used. 

Java is a programming language that is class-based and object-oriented. The aim
of the language is that you should be able to write the code and run it
anywhere.~\cite{java} Haskell is a purely functional programming language, it
also features lazy evaluation which allows composing functions easier. For
example, given the function $three$ where $three = take\; 3 \, \circ \, cycle\;
5$, where cycle is a function that generates an infinitely long list consisting
of a number. $three$ only compute the first three values, I.E. $[5,5,5]$, of the
infinite list.  In a non-lazy program the function would never terminate as
$cycle$ would run forever.~\cite{haskell} The reason these languages where
chosen is because of the authors familiarity with those languages.

\subsubsection*{Simplified chess game}

Chess is a famous game and in this report it is assumed that the reader know how
it works.\footnote{Rules of chess: \url{en.wikipedia.org/wiki/Rules_of_chess}}
The aim is to implement a simplified variant of it. 

\begin{itemize} 
    \item Only pawns and horses exist.
    \item You win by removing all the other players pieces.
\end{itemize}

The player should be able to do the following:

\begin{itemize} 
    \item List all available moves for a certain chess piece. 
    \item Move the chess piece to a given space
    \item Switch player after move
    \item Get an overview of the board
    \item Get an error when making invalid moves
\end{itemize}

To interact with the game, a user types commands through a command line prompt.
An example of basic interaction with the game is displayed in
Figure~\ref{chessexample}.

\begin{figure}[H]
    \centering
    \begin{lstlisting}
        > list (a,2)
        White pawn at (a,2)
        > move (a,2) (a,3)
        White pawn moved to (a,3)
        > listall
        White pawn at (a,3)
        White pawn at (b,2)
        ...
        White Horse at (a,1)
        ...
        Black pawn at (a,8)
        ...
    \end{lstlisting}
    \caption{An example of the interaction in the chess game.}
    \label{chessexample}
\end{figure}


\subsubsection*{To-do List}

A common task in programming is to create some kind of data store with
information. A to-do list is a minimal example of that. It consists of a list of
items that can be used to remember what to do later. The user should be able to:

\begin{itemize}
    \item Create a new item in the to-do list.
    \item Remove an item from the to-do list.
    \item Mark an item from the to-do list as done.
    \item See all items in the to-do list.
\end{itemize}

The interface to this program will be a text interface, displaying each item in
the todo list. To navigate and mark an item in the list the user presses up and
down and presses \texttt{x} to mark it.

\subsubsection*{Kudos bot}

When working in big teams we need to automate common tasks. A common application
for communication is Slack\footnote{See more: \url{www.slack.com}}. The task
here is to create an bot that allows people to send kudos to collegues when they
have done a good job

\begin{itemize}
    \item The user should be able to type ``/kudos Username `msg''' where
        username is the name of the person they want to thank and msg is the
        message.
    \item The receiving user should be notified
    \item By typing ``/kudos all'' the user should be able to see the score of
        all kudos that have been given.
\end{itemize}

