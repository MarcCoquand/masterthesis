\chapter{Method}\label{method}

Now that we have established what RESTful servers are and what the development
challenges arise when creating them, the goal is to evaluate the potential of
functional programming for better software quality. We established that two
things need to be addressed for software structural quality: the avoidance of
rotten design and good readability. By creating a semi-structured interview,
where the subjects are asked open questions about how the code works then it can
give insights about the readability of the source code. Adherence to SOLID
principles can be used to avoid rotten design, thus we also need to evaluate the
servers adherence to those principles. If the library can enforce that SOLID
principles are followed through the type system, that the source code is
readable and that the library forces the developers to follow the REST API then
the servers produced by the library would have good software quality. In this
chapter, we, therefore, describe how we can evaluate the software structural
quality through interviews and using SOLID principles so that we can evaluate
our solution's software quality. We then also describe how we can compare it to
another solution written in imperative programming to see if it gives
improvement over existing solutions.

\subsection{Aims}

To evaluate if the functional approach to creating servers is more maintainable
than existing solutions, a comparative study will be done.  A popular library
for developing server applications is by using an unopinionated solution using
Express, which is a good candidate to compare to a functional library which will
be explained further in Chapter~\ref{theory}.  Express is an unopinionated server
framework written for Node.js for JavaScript.  That a framework is unopinionated
means that it does not force you to architecture your code in any specific
way.(ADD\_REFERENCE UNOPINIATED) An idiomatic server was made using the library
in Chapter~\ref{theory} and the popular framework for Node Express. They feature
similar functionality which is a REST API with the endpoints:

\begin{itemize}
    \item \texttt{GET ``api/books?released=int\&author=string''} Get a list of
    books and optionally ask for a specific author or a book from a specific
    year
    \item \texttt{DELETE ``api/books/:id''} Delete a book with a specified ID.
    \item \texttt{POST ``api/books/:id'' OR ``api/books/''} Create a new book or
    override a specific book
\end{itemize}

The server will make use of a database that is abstracted away in the
implementation. The supported content types will be \texttt{application/json}
and for all endpoints and the displayable content-types are \texttt{text/plain}
and \texttt{application/json}.  They were written in an idiomatic way, that is
they did not take the challenges outlined in Chapter~\ref{background} into
consideration.

\section{Evaluating maintainability}\label{evaluatingmaintainability}

The aspects that to be evaluated when measuring maintainability were discussed
in Chapter~\ref{background}. To recap the important aspects were:

\begin{itemize}
    \item Testability
    \item Extendability
    \item Readability
    \item Error-proneness
\end{itemize}

Chapter~\ref{background} established that the SOLID principles can be used as
guidelines for creating maintainable software. Those principles will be used as
criteria that Cause should be evaluated against.  However these guidelines do
not state anything about the readability of the software.  Thus two different
methods will be used to measure readability and to measure the testability,
extendability, and error-proneness.

\subsection{Evaluating readability through code reviews}

Code reviews, also known as peer reviews, is an activity where a human evaluates
the program to check for defects, finding better solutions and find readability
aspects. (ADD\_REFERENCE Code reviews)

To measure the readability of the REST library, a semi-structured code review is
conducted on five different people with varying knowledge of REST APIs and
functional programming.

\subsubsection{Semi-structured interviews}

Semi-structured interviews diverge from a structured interview which has a set
amount of questions. In a semi-structured interview, the interview is open and
allows for new ideas to enter the discussion. (ADD\_REFERENCE semi structured
interviews) Semi-structured interviews are used to gather focused qualitative
data. It is useful for finding insights about the readability of the code and if
the code can be understood by others.

To conduct a semi-structured interview, the interview should avoid leading
questions and use open-ended questions to get descriptive answers rather than
yes or no answers. The questions that will be asked are presented below.

\begin{description}
    \item[Q1] What is your experience with RESTful APIs?
    \item[Q2] What is your experience with Express?
    \item[Q3] What is your experience with ReasonML?
    \item[Q4] After being presented the code API, can you explain what it does?
    \item[Q5] Which media types does the endpoint post accept?
    \item[Q6] What is the URI of DELETE?
    \item[Q7] Which media types representations can the endpoint show?
    \item[Q8] Given a handler putInDatabase, Can you demonstrate how you would
        extend the API and add a new endpoint for a PUT request.
    \item[Q9] Looking at the JavaScript API, can you explain what it does?
    \item[Q10] Which media types does the endpoint get accept?
    \item[Q11] Which content type and accept does post have?
\end{description}

The interviewer will also be informed that the name of the file of the code is
BookApi.re, re is the file extension of ReasonML, and BookApi.js, js is the file
extension of javascript, respectively. 

\subsection{Evaluating the answers}

After performing the interviews conclusions can be made by interpreting the
answers to conclude if the code is readable or not. If the code is readable the
users being interviewed should be able to explain to the author what the code
does.

So in summary, the way each aspect of maintainability will be evaluated in both
solutions by the following:

\begin{description}
    \item [Testability] Evaluated by comparing the number of dependencies that
    need to be mocked. 
    \item [Extendability] Evaluated by comparing to SOLID principles.
    \item [Readability] Evaluated by comparing to SOLID principles.
    \item [Error-proneness] Evaluated by SOLID principles and the interviews
        where we ask to extend the solution with a PUT request.
\end{description}

From there a discussion can be had about the strengths and weaknesses of both
solutions and the impacts of maintainability by using functional programming for
developing REST servers.





