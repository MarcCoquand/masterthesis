\chapter{Introduction: Software paradigms and complexity}\label{introduction}

Different schools of thoughts have different approaches when it comes to
building applications. There is one that is the traditional, object oriented,
procedural way of doing it. Then there is a contender, a functional approach, as
an alternative way to build applications.  Early programming languages were
based around procedure calls. Procedures are the series of steps the computer
needs to perform the computations desired.~\cite{proceduralprogramming} These
programming languages were turing complete. A programming language is Turing
complete if is able to calculate everything that is
calculatable.~\cite{turingmachine} Object-oriented programming is used to make
code more reusable and structured. Java, amongst most languages, is a popular
language that is turing complete, object-oriented and imperative.~\cite{java} 

Functional programming originates from 1936 from Lambda calculus. Lambda
calculus is a theory for functions and evolved from Church and Curry to create
an alternative foundation for mathematics.~\cite{Turner} Even though Turing
machines and Lambda calculus developed separately, the church-turing thesis
proves that any computational problem that is solvable with Lambda Calculus is
also solveable for Turing machines and vice versa.~\cite{sep-church-turing} What
this means in practice is any program written in the functional paradigm can be
written in the procedural, object-oriented paradigm. However it does not mean
that the paradigms are the same as one solution might be very complex in a
procedural language and simple in a functional language and vice versa as long
as they are turing-complete.

As software engineers, one factor of concern is software quality. Software
quality can be divided into two different subparts: software functional quality
and software structural quality. Software functional quality reflects how well
our system conforms to given functional requirements or specification and the
degree of which we produce correct software.  To check that the software is
correct, software engineers create tests.~\cite{Pressman:2004:SEP:994110} If a
software engineer has to write more tests it could potentially lead to affecting
software quality.  By looking at cyclomatic complexity, described in
Section~\ref{cyclomaticcomplexity}, one can find out how the different software
paradigms affect the amount of tests we need to write.  

Software structural quality refers to how well the software adheres to
non-functional requirements such as robustness and
maintainability.~\cite{Pressman:2004:SEP:994110} Some of the maintainability
aspects, such as usability, is hard to measure quantitatively. By looking at the
cognitive dimensions, described in Section~\ref{cognitivedimensions}, one can
use an expert analysis to find how the two approaches affect the usability for
the developer. So by looking at different case studies this study aims to find
if the different software paradigms affect software quality. 

