\chapter{Introduction: Software paradigms and complexity}\label{introduction}

Different schools of thoughts have different approaches when it comes to
building applications. There is one that is the traditional, object oriented,
procedural way of doing it. Then there is a contender, a functional approach, as
an alternative way to build applications.  Early programming languages were
based around procedure calls. Procedures are the series of steps the computer
needs to perform the computations desired.~\cite{proceduralprogramming} These
programming languages were turing complete. A programming language is Turing
complete if is able to calculate everything that is
calculatable.~\cite{turingmachine} Object-oriented programming is used to make
code more reusable and structured. Java, amongst most languages, is a popular
anguage that is turing complete, object-oriented and imperative.~\cite{java} 

Functional programming originates from 1936 from Lambda calculus. Lambda
calculus is a theory for functions and evolved from Church and Curry to create
an alternative foundation for mathematics.~\cite{Turner} Even though Turing
machines and Lambda calculus developed separately, the church-turing thesis
proves that any computational problem that is solvable with Lambda Calculus is
also solveable for Turing machines and vice versa.~\cite{sep-church-turing} What
this means in practice is any program written in the functional paradigm can be
written in the procedural, object-oriented paradigm. However it does not mean
that the paradigms are the same as one solution might be very complex in a
procedural language and simple in a functional language and vice versa as long
as they are turing-complete.

As software engineers, one factor of concern is software quality. Software
quality can be divided into two different subparts: software functional quality
and software structural quality. Software functional quality reflects how well
our system conforms to given functional requirements or specification and the
degree of which we produce correct software.  To check that the software is
correct, software engineers create tests.~\cite{Pressman:2004:SEP:994110} In
order to create tests, the engineer employs various patterns and tools in the
code to make the code easier to test, from SOLID principles to Object-oriented
programming.

Software structural quality refers to how well the software adheres to
non-functional requirements such as robustness and
maintainability.~\cite{Pressman:2004:SEP:994110} Some of the maintainability
aspects, such as readability, is hard to measure quantitatively. By performing
semi-structured interviews, it is possible to investigate how well the code is
understood. Since functional programming is not the most popular approach to
software engineering today, it is worth taking into consideration how employing
functional programming might affect the readability and maintainability of
the software. If no one understands the code, how can they be expected to
maintain the software?

In software engineering, defects are still common place with the average defect
rate being 15- 50 per 10000. (ADD\_REFERENCE Steve McDonnell Code complete)  In
this thesis, the aim is to investigate what makes software maintainable and can
those criterias that make software maintainable be enforced and with Functional
programming. This will be done by investigating the domain of servers. The
server domain is predominently dominated by imperative and object-oriented
languages like Java, C\#, Go and Javascript.(ADD\_REFERENCE statistics) Thus
this thesis will show how Functional programming helps solving a lot of common
issues related to development of maintainable servers that follow a
specification called REST.
