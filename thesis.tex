\title{Comparing Testability and Code Quality in Software Paradigms}
\author{
        Marc Coquand\\
        Department of Computer Science\\
        UmeÃ¥ University\\
}
\date{\today}


\documentclass[12pt]{article}
\usepackage{listings}
\usepackage{amsthm}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usepackage{romande}
\usepackage[T1]{fontenc}
\usepackage{float}

\theoremstyle{definition}
\newtheorem*{definition}{Definition}

\theoremstyle{theorem}
\newtheorem*{theorem}{Theorem}

\lstdefinestyle{customc}{
	belowcaptionskip=1\baselineskip,
	breaklines=true,
	xleftmargin=\parindent,
    numbers=left,
    numberstyle=\ttfamily\color{gray},
	language=Java,
	showstringspaces=false,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\bfseries\color{green!40!black},
	commentstyle=\itshape\color{purple!40!black},
	identifierstyle=\color{black},
	stringstyle=\color{orange},
}
\lstdefinestyle{customasm}{
	belowcaptionskip=1\baselineskip,
	frame=L,
	xleftmargin=\parindent,
	language=[x86masm]Assembler,
	basicstyle=\footnotesize\ttfamily,
	commentstyle=\itshape\color{purple!40!black},
}
\lstset{escapechar=@,style=customc}

\begin{document}
\maketitle

\begin{abstract} 

    This study's goal is to compare approaches to functional programs and
    object-oriented programs to find how it affects maintainability and code
    quality. By looking at 3 cases, we analyze, how does a functional approach
    to software architecture compare to an OOP (Object-oriented programming)
    approach when it comes to maintainability and code quality? TO BE REPLACED
    WITH CONCLUSION

\end{abstract}

\section{Introduction}
This is time for all good men to come to the aid of their party!

\section{Objective}

Different schools of thoughts have different approaches when it comes to
building applications. There is one that is the traditional, object oriented,
procedural way of doing it. Then there is a contender, a functional approach, as
an alternative way to build applications. When building applications testability
is of high concern to ensure that the application functions properly. By looking
at cyclomatic complexity, described in Section~\ref{cyclomaticcomplexity}, we
can find out how the different approaches affect the amount of tests we need to
write to get full branch coverage. By looking at the cognitive dimensions,
described in Section~\ref{cognitivedimensions}, we can find how the two
approaches affect the mental complexity for the developer. 


\section{Theory}\label{theory}

\subsection{Characteristics of Functional Programming}
Expressions and functions

\subsubsection{Iterator pattern}

\subsection{Object Oriented Programming}\label{oop}
Uses variables, commands and procedures

\subsubsection{SOLID principles}

\section{Methods}\label{methods}

\subsection{Measuring testability: Cyclomatic Complexity}\label{cyclomaticcomplexity}

Cyclomatic complexity is a complexity measure that allows us to measure the
amount of paths through a program. The Cyclomatic complexity is an upper bound
for the number of test cases required for full branch coverage of the code. 

\theoremstyle{definition}
\begin{definition}
The cyclomatic number $v(G)$ of a graph G with $n$ vertices, $e$ edges and $p$
connected components is $v(G) = e - n + p$.
\end{definition}

\begin{theorem}
In a strongly connected graph $G$, the cyclomatic number is equal to the
maximum number of linearly independent circuits.~\cite{McCabe}
\end{theorem}

Informally, we can think of cyclomatic complexity as a way to measure the amount
tests a program needs to reach full branch coverage. We construct a graph that
branches out based on when the control flow in our source code branches out. For
example, given \texttt{f(bool) = if bool then 1; else 2}, the function
\texttt{f} will either be 1 or 2. The function \texttt{f} will need two tests in
order to have full code coverage. The cyclomatic complexity in this case is 2.
The nodes of the graph represents processing tasks and edges represent control
flow between the nodes. 

\begin{figure}[H]
    \begin{lstlisting}
        void foo(void)
        {
          if (a)
            if (b) 
              x=1;
          else
              x=2;
         }
    \end{lstlisting}
    \caption{Example for cyclomatic complexity.}\label{c1excode}
\end{figure}

If we have the code found in example figure~\ref{c1excode}. To calculate the
complexity of this function we first construct a graph as seen in
figure~\ref{fig:c1exgraph}. From the graph we find $n=4, e=5, p=2\Rightarrow
v(G)=e-n+p=5-4+2=3$ is the cyclomatic number.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \tikzset{vertex/.style = {shape=circle,draw,minimum size=2.5em}};
        \tikzset{edge/.style = {->,> = latex'}};
        \node[vertex] (a) at (2,8) {\texttt{if (a)}};
        \node[vertex] (b) at (0,6) {\texttt{if (b)}};
        \node[vertex] (c) at (4,6) {};
        \node[vertex] (d) at (2,4) {end};
        \draw[edge] (a)  to (b);
        \draw[edge] (a)  to (c);
        \draw[edge] (b)  to (c);
        \draw[edge] (b)  to (d);
        \draw[edge] (c)  to (d);
    \end{tikzpicture}
    \caption{Cyclomatic complexity graph for figure~\ref{c1excode}}\label{fig:c1exgraph}
\end{figure}

\subsubsection{Cyclomatic Complexity in Functional Programming}

The definition of cyclomatic complexity in Section~\ref{cyclomaticcomplexity} is
not ideal for functional programming. Cyclomatic complexity is calculated by
creating graphs based on control flow operations such as while loops and if
statements. In functional programming everything is a function, thus the
cyclomatic complexity will always tend to 0 using this definition. So we define
a different method of calculating the cyclomatic complexity for functional
programs. 

\theoremstyle{definition}
\begin{definition}
    The cyclomatic complexity number, in functional programming, for a function
    is equal to 1 plus the sum of the left hand side, called LHS, plus the sum
    of the right hand side, called RHS. RHS is the sum of the number of guards,
    logical operators, filters in a list comprehension and the pattern
    complexity in a list comprehension. LHS is equal to the pattern complexity.
    The pattern complexity is equal to the number of identifiers in the pattern,
    minus the number of unique identifiers in the pattern plus the number of
    arguments that are not identifiers. In summary:

    \begin{lstlisting}
    Cyclomatic complexity = 1 + LHS + RHS

    LHS = Pattern complexity 

    Pattern complexity   
        = Pattern identifiers 
        - Unique pattern identifiers 
        + Number of arguments that are non identifiers

    RHS = Number of guards 
        + Number of Logical operators 
        + Number of filters in list comprehension 
        + Pattern complexity in list comprehension
    \end{lstlisting}
\end{definition}

Instead of cyclomatic graphs we instead construct flowgraphs, such as the one
seen in Figure~\ref{fig:cyclomaticfunctional} to model our function.

\begin{figure}[H]
    \begin{lstlisting}
    split :: (a -> Bool) -> [a] -> ([a], [a])
    split onCondition [] = ([], [])
    split onCondition (x:xs) =
        let 
            (ys, zs) = split onCondition xs
        in 
            if (onCondition x) then 
                (x:ys, zs)
            else 
                (ys, x:zs)
    \end{lstlisting}
    \caption{Recursively split a list into two based on a given condition in
    Haskell. For example \texttt{split (>3) [1,2,3,4,5] =
    ([4,5],[1,2,3])}.}\label{fig:split}
\end{figure}

In Haskell $(x:xs)$ denotes an item $x$ at head of a list of items $xs$. Given
the Haskell code in Figure~\ref{fig:split}. To calculate LHS we find two
pattern identifiers which are $onCondition$ and $(x:xs)$. there is one unique
pattern identifiers which is $(x:xs)$. There is also one non identifier
which is $[]$. We also find one guard, an if statement, and no
list comprehensions on RHS. Thus the cyclomatic complexity is $1+(2-1+1)+1=4$.
<-- NEEDS VERIFICATION FROM SOMEONE, THE SOURCE IS VERY VAGUE HERE\ldots

We do not count the $otherwise$ and $else$ clauses as a guard, just as how we
do not count the $else$ statement in normal procedural cyclomatic
complexity.~\cite{bergklaas}


\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \tikzset{vertex/.style = {shape=circle,fill=black,scale=0.5}};
        \draw[dashed] (0,0) -- (0,-5) (2,0) -- (2,-5) (4, 0) -- (4, -5) (6, 0)
        -- (6, -5);
        \node at (0,.3) {\small{Patterns}};
        \node at (2,.3) {\small{Guards}};
        \node at (4,.3) {\small{Expressions}};
        \node at (6,.3) {\small{Stop}};
        \node[vertex] (a) at (0,-0.3) {};
        \node[align=right, text width=3cm] at (-2,-0.3) {\texttt{[]}};
        \node[vertex] (b) at (4,-1.2) {};
        \draw[->, very thick] (a) to node [above] (TextNode) {T} (b) ;
        \node[vertex] (c) at (0,-1.5) {};
        \node[align=right, text width=3cm] at (-2,-1.5) {\texttt{(x:xs)}};
        \draw[->, very thick] (a) to node [left] (TextNode) {F} (c) ;
        \node[align=left, text width=3cm] at (8,-1.2) {\texttt{e1=([],[])}};
        \node[vertex] (d) at (2,-2.1) {};
        \draw[->, very thick] (c) to node [above] (TextNode) {T} (d) ;
        \node[align=right, text width=3cm] at (-2,-2.1) {\texttt{onCondition x}};
        \node[vertex] (e) at (4,-2.8) {};
        \draw[->, very thick] (d) to node [above] (TextNode) {T} (e) ;
        \node[align=left, text width=3cm] at (8,-2.8) {\texttt{e2=(x:yz, zs)}};
        \node[vertex] (f) at (4,-3.8) {};
        \draw[->, very thick] (d) to node [below] (TextNode) {F} (f) ;
        \node[align=left, text width=3cm] at (8,-3.8) {\texttt{e3=(yz, x:zs)}};
        \node[vertex] (g) at (6,-4.8) {};
        \draw[->, very thick] (e) to (g) ;
        \draw[->, very thick] (b) to (g) ;
        \draw[->, very thick] (f) to (g) ;
        \draw[very thick] (c) to (2, -4.0) to (g) ;
    \end{tikzpicture}
    \label{fig:cyclomaticfunctional}
    \caption{Flowgraph for split.}
\end{figure}

\subsection{Mental complexity: Cognitive Dimensions}\label{cognitivedimensions}

Cognitive Dimensions is a framework for evaluating the usability of programming
languages and to find areas of improvements. Used as an approach to analyse the
quality of a design, it also allows to explore what future designs could be
possible. As part of the Cognitive Dimensions, 14 different Cognitive Dimensions
of Notation exist. A notation depends on the specific context, in this case will
be the languages themselves and their architecture.~\cite{GREEN1996131}

\subsubsection{Viscosity}

How much work does it take to make small changes? How easy is the code to
refactor?

\subsubsection{Visibility}

How easy is it to navigate the source code to find the parts that you want?

\subsubsection{Premature Commitment}

Are there any architectural decisions that must be made before all the necessary
decisions have been made? Can we correct those decisions later, how safe is the
refactoring and how much is needed?

\subsubsection{Hidden Dependencies}

Are there hidden dependencies in the source code. Does a change in one part of
the source code lead to unexpected consequences in another part of the code.

\subsubsection{Role-Expressiveness}
\subsubsection{Abstraction}

What are the levels of abstraction in the source code? Can the details be
encapsulated?

\subsubsection{Secondary Notation}



\subsubsection{Closeness of Mapping}

By looking at the source code, how close do we find it to be to the case
we are solving?

\subsubsection{Consistency}

Once Object-oriented procedural programming and Functional programming has been
learned. How much of the rest can the user guess successfully? 

\subsubsection{Diffuseness or terseness}

How much space and symbols does the source code need to produce a certain result
or express a meaning?

\subsubsection{Hard Mental Operations}

Where does the hard mental processing lie? Is it more when writing the source
code itself rather than solving the case, I.E. the semantic level? Do you
sometimes need to resort to pen and paper to keep track of what is happening?

\subsubsection{Provisionality}

\subsubsection{Progressive Evaluation}

How obvious the role of each component of the source code in the solution as a
whole?

\subsection{Case studies}

To compare the different paradigms using Cognitive dimensions and measuring
Cyclocmatic complexity we will look at three different cases. The cases were
chosen based on how they are often subproblems in bigger applications.

\subsubsection{Simplified chess game}

Chess is a famous game and assumed that the reader know how it works. Aim
is to implement a simplified variant of it. This is not ordinary chess but a
simplified version:

\begin{itemize} 
    \item Only pawns and horses exist.
    \item You win by removing all the other players pieces.
\end{itemize}

The player should be able to do the following:

\begin{itemize} 
    \item List all available moves for a certain chess piece. 
    \item Move the chess piece to a given space
    \item Switch player after move
    \item Get an overview of the board
    \item Get an error when making invalid moves
\end{itemize}

To interact with the game, a user types commands through a command line prompt.
An example of basic interaction with the game is displayed in
Figure~\ref{chessexample}.

\begin{figure}[H]
    \centering
    \begin{lstlisting}
        > list (a,2)
        White pawn at (a,2)
        > move (a,2) (a,3)
        White pawn moved to (a,3)
        > listall
        White pawn at (a,3)
        White pawn at (b,2)
        ...
        White Horse at (a,1)
        ...
        Black pawn at (a,8)
        ...
    \end{lstlisting}
    \label{chessexample}
    \caption{An example of the interaction in the chess game.}
\end{figure}


\subsubsection{to-do List}

A common task in programming is to create some kind of data store with
information. A to-do list is a minimal example of that. It consists of a list of
items that can be used to remember what to do later. The user should be able to:

\begin{itemize}
    \item Create a new item in the to-do list.
    \item Remove an item from the to-do list.
    \item See all items in the to-do list.
    \item Update an item from the to-do list.
\end{itemize}

\subsubsection{Chatbot engine}

Oftentimes when developing applications we have to deal with complex information
input. One of those cases is when we have chat bots. Chat bots are interactive
programs that respond with a text answer to the users input. For this
application we will implement the following:

\begin{itemize}
    \item Interpretor that can handle semi-complex inputs and deal with errors.
    \item Give answers to those inputs in form of text messages.
\end{itemize}    

\section{Results}\label{results}
We worked so hard, yet achieved very little.

\section{Limitations}\label{limitations}

\subsection{Improvements to implementation}

\bibliographystyle{abbrv}
\bibliography{thesis}

\end{document}
