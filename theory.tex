\chapter{Theory}\label{theory} 

Based on the challenges outlined in Chapter~\ref{background}, the goal now
becomes to construct a library for REST apis that is compliant by construction
to ensure software structural quality, introduced in Chapter~\ref{introduction}.
This chapter will introduce the fundamentals of functional programming to then
move on and use that to construct a server library which can be used to produce
REST compliant servers.

\section{Concepts from Functional Programming}\label{functionalprogramming}

 While different definitions exist of what Functional programming means, here 
 functional programming is a paradigm that uses of pure functions,
 decoupling state from logic and immutable data.

\begin{description}
\item[ Purity ]

When a function is pure it means that calling a function with the same arguments
        will always return the same value and that it does not mutate any value.
        For example, given $f(x) = 2\cdot x$, then $f(2)$ will always
        return $4$. It follows then that an impure functions is either dependant
        on some state or mutates state in some way. For example, given $g(x) =
        currenttime \cdot x$, $g(5)$ will yield a different value depending on
        what time it is called. This makes it dependant on some state of the
        world. Or given $x=0$, $h()=x+1$. Then $h()$ will yield $x=1$ and $(h
        \circ h)()$ will yield $x=2$, making it impure.~\cite{wikipedia_pure}

\item[ Immutable data by deafult ]

Immutable data is data that after initialization can not change. This means if
we initialize a record, \texttt{abc = \{a: 1, b: 2, c: 3\}} then \texttt{abc.a
:= 4} is an illegal operation. Immutable data, along with purity, ensures that
no data can be mutated unless it is specifically created as mutable data.
Mutable data is an easy source of bug because it can cause two different
functions to modify the same value, leading to unexpected results.

\item[Higher-order functions]

	Higher-order functions are functions which either return a function or take
one or more functions as arguments. A function $twice : (a\rightarrow
a)\rightarrow (a\rightarrow a)$, $twice\ f = f \circ f$, takes a function as an
argument and returns a new function which performs given function twice on the
argument. 

\item[Partial Application] 
    It is possible in functional languages to \textit{partially apply} a
    function, meaning that we only supply some of the functions arguments, which
    yields a function instead of a value. For example, given a function $sum a b
    = a + b$, we can partially apply this function to create a function $add3 a
    = sum 3 a$. 

\item[Decoupling state from logic]

Even if functional programs emphasise purity applications still need to deal
        with state somehow. For example a server would need to interact with a
        database. Functional programs solve this by separating pure functions
        and effectful functions. Effects are observable interactions with the
        environment, such as database access or printing a message.  While
        various strategies exist, like Functional Reactive
        Programming\footnote{Read more:
        \url{en.wikipedia.org/wiki/Functional_reactive_programming}},
        Dialogs\footnote{Read more:
        \url{stackoverflow.com/questions/17002119/haskell-pre-monadic-i-o}} or
        uniqueness types\footnote{Read more:
        \url{https://en.wikipedia.org/wiki/Clean_(programming_language)}}, the
        one used in Haskell (the language used in this thesis to construct the
        programs) is the IO monad. For the uninitiated, one can think of Monads
        as a way to note which functions are pure and which are effectful and
        managing the way they intermingle. It enables handling errors
        and state.\footnote{This is simplified as Monads are notoriously
        difficult to explain.}. 

As a strategy to further separate state and logic, one can construct a
        three-layered architecture, called the three layer Haskell cake. Here,
        the strategy is that one implements simple effectful functions,
        containing no logic as a base layer. Then on a second layer one
        implements an interface that implements a pure solution and one
        effectful solution. Then on the third layer one implements the logic of
        the program in pure code.  
\end{description}

So while no exact definition of Functional programming exist, this thesis
defines it as making functions pure and inheritance being based around
functionality rather than attributes. 

More advanced constructs also exists for functional programming that need to be
introduced for constructing a maintainable rest library. 

\subsection{Functors and Contravariant Functors}

The Functor type class defines a function $map : (a\rightarrow b) \rightarrow m\
a \rightarrow m\ b$. So every type that can be mapped over is a Functor.
Examples of this are lists, where map morphs every value in the list from a to
b. Another example is for Maybe, defined in~\ref{types}. A Functor for Maybe
checks if the value is $Just\ a$, if so it morphs that value to $Just\ b$,
otherwise it returns $Nothing$. 

Not every type with a type parameter is a Functor. For example the type
$Predicate\ a = a \rightarrow Boolean$, is a function that when given some value
$a$ returns a boolean. This type can not be a Functor due to the type parameter
being the \textit{input} of the function. When the type parameter of the type is
the input, it is said to be in negative position and the type is
\textit{contravariant}.  When the type parameter is the output of a function, it
is said to be in positive position and the type is covariant. A type can be a
Functor only if it is covariant.

Contravariant Functor type class define a function $contramap : (a\rightarrow b)
\rightarrow m\ b \rightarrow m\ a$. These are useful for defining how the value
should be \textit{consumed}. So for example a $type\ encoder = a\rightarrow
encoded$, defines an encoder. The contravariant functor would allow transforming
the encoder into intermediate value.


\subsection{ADTs: Sum types and product types}\label{types}

A type is in Haskell a \textit{set} of possible values that a given data can
have. This can be $int$, $char$ and custom defined types. A \textit{sum type},
\textit{Algebraic data type (ADT)} or \textit{union type} is a type which is the
sum of types, meaning that it can be one of those it's given types. For example
the type \texttt{type IntChar = Int | Char} is either an Int or a Char. A useful
application for sum types are enums such as \texttt{type Color = Red | Green |
Blue}, meaning that a value of type Color is either red, green or blue. A sum
type can be used to model data which may or may not have a value, by introducing
the Maybe type: \texttt{type Maybe value = Just value | Nothing}.A product type
is a type which is the product of types, for example \texttt{type User = User
Name Email}.  Informally, a product type can be likened to a record in
Javascript.  This allows us to model computations that might fail. For example
given $sqrt(x) = \sqrt{x},\, x\in \mathbb{Z}$ then $sqrt(-1)$ is undefined and
would cause Haskell to crash.  Instead by introducing a function
\texttt{safeSqrt}, where \texttt{safeSqrt x = if x > 0 then Just (sqrt x) else
Nothing}, the program can force the developer to handle the special case of
negative numbers. 

\subsection{Domain-specific languages}

A domain specific language (DSL) is a programming language specified for a
specific domain. Typical examples of DSLs are HTML for designing web pages and
SQL for making database calls. An eDSL is such a language embedded within the
syntax of the language. EDSLs are useful due to the ability to separate the
evaluation of the logic of the program to the logic itself. In the case of REST
apis, this means we can develop an eDSL which can interpret REST apis and use
them for different purposes. Since the logic is separated from the evaluation it
also gives the advantage that testing is required for the evaluator and not for
the logic itself (since testing it means just testing that it's equal to
itself). To test evaluators can be done in separation using property-based
testing (ADD\_REFERENCE testing the hard stuff John hughes), thus allowing the
developer to ensure that any program written using the GADT is correct by
extension.

\subsection{Generalized algebraic data type}\label{gadt}

One method for constructing eDSLs in functional programming is through the use
of \textit{generalized algebraic data type} (GADT).(ADD\_REFERENCE GADT)  They
specify, depending on the input, what the output should be of that type. GADT
enables implementing \textit{domain-specific languages} (DSL) easily and ensure
that the DSL is statically correct. 

\begin{figure}[H]
    \begin{lstlisting}
type Calculator 
    Number : Int  -> Calculator Int
    Bool : Bool -> Calculator Bool
    Add : Calculator Int -> Calculator Int -> Calculator Int
    Multiply : Calculator Int -> Calculator Int -> Calculator Int
    Equal : Calculator a -> Calculator a -> Calculator Bool
    \end{lstlisting}
    \caption{A Calculator GADT with three operations add, eq and multiply.}
    \label{gadtcalculator}
\end{figure}

\begin{figure}[H]
    \begin{lstlisting}
mathExpression = (Number 5 `Add` Number 3) `Multiply` (Number 4 `Add` Number 3)
    \end{lstlisting}
    \caption{A mathematical expression constructed using the GADT in
    figure~\ref{gadtcalculator}}
    \label{mathexpressiongadt}
\end{figure}


Figure~\ref{gadtcalculator} demonstrates a minimal example GADT for a
calculator. The calculator has five constructors: $Number$, $Bool$, $Equal$
$Add$ and $Multiply$. From this we can construct mathematical expressions and
ensure that they are correct by constructions, or else they will not compile.
If we attempt to construct an expression $Add\ (Bool\ False)\ (Number\ 5)$ the
compilation will fail as $Multiply$ expects a number or an expression. However
only having the expression is not very useful without some way of evaluating it.
In Figure~\ref{calculator} we demonstrate how we can evaluate the expression
using pattern matching.

\begin{figure}[H]
    \begin{lstlisting}
evaluate : forall a. Calculator a -> Int
evaluate (Add expr1 expr2) = evaluate expr1 + evaluate expr2
evaluate (Multiply expr1 expr2) = evaluate expr1 + evaluate expr2
evaluate (Equal expr1 expr2) = (evaluate expr1) == (evaluate expr2)
evaluate (Number i) = i
evaluate (Bool b) = b
    \end{lstlisting}
    \caption{Evaluator for the calculator}
    \label{calculator}
\end{figure}

Another example of GADTs is the creation of type safe lists, where we can be
sure statically that performing $head$ will yield an answer. This is
demonstrated in Figure~\ref{safelist}

\begin{figure}[H]
    \begin{lstlisting}
type Empty
type NonEmpty

type SafeList a b =
     Nil : SafeList a Empty
     Cons : a -> SafeList a b -> SafeList a NonEmpty

safeHead : SafeList a NonEmpty -> a
safeHead (Cons x _) = x
    \end{lstlisting}
    \caption{Type safe list}
    \label{safelist}
\end{figure}

By separating how the expression from it's evaluation, the expression can be
reused for different purposes. For instance it would be possible to use the same
logic for the calculators and implement them for different platforms and ensure
statically that all platforms follow the same logic. So GADTs are useful for
creating expressions that can later on be evaluated.

\section{Servers using GADTs: Router}

Using GADTs, we can construct a statically correct eDSL for server
routers.(ADD\_REFERENCE code from
https://github.com/elm/package.elm-lang.org/blob/master/src/backend/Server/Router.hs)
A server router parses incoming requests and extracts query parameters and
parameters and executes a function depending based on the result. We first
define a minimal example of a GADT $Router$, in Figure~\ref{routergadtminimal}.
The two constructors $Top$ and $Exact$ describe matching \url{/} or for a given
string $s$, \url{/s} respectively. It should also be possible to link two
$Router$ together to allow us to match nested urls. Thus we can introduce
$Compose$ which allows composing routers together composed of multiple parts.
For instance \url{/hello/world} corresponds to $Compose\ (Exact\ "hello")\
(Exact\ "world")$.

\begin{figure}[H]
    \begin{lstlisting}
type Router 
    Top : Router 
    Exact : String -> Router 
    Compose : Router -> Router -> Router
    \end{lstlisting}
    \caption{Minimal router GADT}
    \label{routergadtminimal}
\end{figure}


Definition in Figure~\ref{routergadtminimal} is not sufficient as a route can
also contain parameters, such as integers for id or strings.  These parameters
need to be applied to a function which can handle them. We can use GADTs to also
describe the transformation of the functions argument from some start parameter
to some end parameter. In Figure~\ref{extendedrouter} we extend the router with the
constructors Integer and String. When evaluated later, Integer and String
describe that they transform a function which takes an argument ($String$ or
$Int$) and returns result. $Compose$ allows us to compose these parameters
together, so an api for a user resource could be implemented as \texttt{Compose
(Compose (Exact "user") String) Integer}, which could be interpreted to match on
urls formatted as \url{/users/:string/:int} where \url{:string} is a valid
string and \url{:int} is a valid int. These arguments get applied to the
handler, thus the type of this value becomes \texttt{Router (String -> Int -> a)
a}.

\begin{figure}[H]
    \begin{lstlisting}
type Router start result 
    Top : Router start result
    Exact : String -> Router start result
    Integer : Router (Int -> result) result
    String : Router (String -> result) result
    Compose : Router a b -> Router b c -> Router a c
    \end{lstlisting}
    \caption{Router GADT extended with Int and string}
    \label{extendedrouter}
\end{figure}

So $Router$ can describe a specification for what the type signature of the
handler must be and what it must then produce. Finally there needs to be a way
to apply that handler to the arguments so that it can produce that value, so we
add a constructor to $Router$, \texttt{Produce : function -> Router function
output -> Router (output -> c) c}. So the final GADT for the router eDSL becomes
the one in Figure~\ref{finalrouter}. \texttt{Router (output -> c) c} informally
translates to ``give me something that can transform the output to c and I will
give you c''.

\begin{figure}[H]
    \begin{lstlisting}
type Router start result 
    Top : Router start result
    Exact : String -> Router start result
    Integer : Router (Int -> result) result
    String : Router (String -> result) result
    Compose : Router a b -> Router b c -> Router a c
    Produce : function -> Router function output -> Router (output -> c) c
    \end{lstlisting}
    \caption{Router GADT extended with Int and string}
    \label{finalrouter}
\end{figure}

This section has demonstrated how GADTs are useful for constructing a eDSL for
routers. What was not described is how to interpret the router which is omitted
for brevity. However the source code for the final solution can be found in
Appendix. Furthermore we will extend this functionality to implement all of the
functionality of a REST server.

% \subsection{Type classes}\label{typeclass}

% A type class is a construct that allows for ad hoc polymorphism. This allows to
% create constraints to type variables in parametrically polymorphic types. In
% English, that means that it allows creating interfaces that must be implemented
% for the types. For example the equality type class, defined in
% Figure~\ref{equalitytypeclass}

% \begin{figure}[H]
    % \begin{lstlisting}
% class Eq a where
  % (==) :: a -> a -> Bool
  % (/=) :: a -> a -> Bool
    % \end{lstlisting}
    % \caption{Equality type class in Haskell.}
    % \label{equalitytypeclass}
% \end{figure}

% By defining an Equality type class one can create general functions that can be
% used for anything that is ``equalable''. For example Figure~\ref{printifequal}
% is a function that prints a text if two items are equal. This function can be
% used for floats, ints, tuples and everything else that implements the
% \texttt{Eq} type class. Other uses for type classes is Num which implements
% numeric operations for floats and integers. This is useful for implementing the
% MTL technique which will allow us to implement the Interpreter pattern which
% will be described in the following sections.

% \begin{figure}[H]
    % \begin{lstlisting}
% printIfEqual :: Eq a => a -> a -> IO ()
% printIfEqual a b =
	% if a == b then
		% putStrLn "They are equal"
	% else
		% putStrLn "They are not equal"
    % \end{lstlisting}
    % \caption{A function that prints a text if the two items are equal.}
    % \label{printifequal}
% \end{figure}

% \subsection{Brief introduction to Monads for side effects}\label{monads}

% Monads\footnote{\url{en.wikipedia.org/wiki/Monad_(functional_programming)}} are
% a way to sequence computations that might fail while automating away boilerplate
% code. Figure~\ref{monadclass} shows how Monads are implemented as a typeclass in
% Haskell. It implements the function \texttt{return}, the function bind
% \texttt{(>>=)}, the function sequence \texttt{(>>)} which is bind whilst
% ignoring the prior argument and \texttt{fail} which handles crashes.

% \begin{figure}[H]
    % \begin{lstlisting}
        % class Monad m where  
            % return :: a -> m a  
            % (>>=) :: m a -> (a -> m b) -> m b  
            % (>>) :: m a -> m b -> m b  
            % fail :: String -> m a  
            % fail msg = error msg 
    % \end{lstlisting}
    % \caption{Monad type class in Haskell.}
    % \label{monadclass}
% \end{figure}

% Informally, Monads are as a design pattern that allows us to sequence different
% computations. Without them the developer would have to explicitly check if a
% computation has failed. For example, given the function $unsafeSqrtLog =
% sqrt\,\circ\,log$, then $unsafeSqrtLog(-1)$ would throw an error since $log$ and
% $sqrt$ are undefined for $-1$.  Section~\ref{types} showed how the \texttt{Maybe
% value} type could be used to create a safe computation \texttt{safeSqrt}.  To
% sequence that computation with a function \texttt{safeLog}, the user would have
% to manually check that \texttt{safeSqrt} returned a value \texttt{Just result}
% and not \texttt{Nothing}. Monads allows sequencing these computations without
% explicitly writing this check, so composing \texttt{safeSqrt} and
% \texttt{safeLog} using bind becomes \texttt{safeSqrtLog n = safeSqrt n >>=
% safeLog}. The same idea applies for effectful computations such as fetching data
% from a database.

\section{Functional servers}

A $Server$ is a type function $Request \rightarrow Response$. Simply, given some
Request it should produce some Response where Request is a product of the url,
media type, accept header, content type header and a body.  The Response is a
product of status code, a set of headers where headers are a tuple of strings, a
content type and an encoding. If the Response returns a successful code in the
range of 2XX, 3XX we say it is a successful response. The goal is to ensure that
values of $Server$ are following the REST API specifications.  Thus we define a
function $make$ that can construct a value of $Server$ which follow REST
specifications.

Based on the REST api description outlined in chapter 2, we define a type
$Specification\ input\ output$, which is a GADT for specifying how to transform
input into output. We define $Specification\ Request\ Response$ to mean a
\textit{server specification}, since it defines how to turn a $Request$ (input)
into a $Response$ (output). $Specification$ works as DSL for one or more
\textit{endpoints} within a REST api where an endpoint is one of the following:

\begin{itemize}
    \item A correct URI to access the resource, such as \url{api/user:int}.
        While the final implementations support any type, this implementation
        will only support integers and strings for brevity.
    \item URI should also support query parameters as optional parameters for
        the handler defined below.
    \item A set of content types that it can represent the resource as.
    \item A set of content type representations for the resource that request can
        submit which can be parsed by the server.
    \item A map of the query parameter name and their respective parser,
        where parser is a function of type $string \rightarrow Maybe\ a$)
    \item An HTTP verb
    \item Status code on success
    \item A function, called a handler, which takes some parameters and returns
        either the resource or a failure message and failure code. This is used
        for side effects, for instance database access. We model the result as
        a sum type $Result\ a = Ok\ a\ |\ Fail\ Message\ Code$.
    \item A combination of one of these endpoints.
\end{itemize}

A difference from the $Router$ defined in previous section is that each Endpoint
need to produce \textit{two} intermediate values. One value which is the handler
and another value which is how to encode the result of the handler. We define
the encoder as ResponseBuilder, which is a contravariant of type $a -> encoded$.
Thus we modify the constructer \texttt{Exact : String -> Specification input
output} to \texttt{Exact : String -> Specification (handler, responseBuilder)
(handler, responseBuilder)}. The constructor \texttt{Integer} becomes
\texttt{Integer : Specification (int -> a, r) (a, r)}.

We also introduce a few new constructor, one being \texttt{Accept} which takes a
list of encoders and their corresponding accept header (\texttt{(Mediatype, [r
-> encoded])}) and produces a \texttt{Specification (a, encoded) (a, r)}, or
with responsebuilder's definition expanded it produces \texttt{Specification
(a, encoded) (a, r -> encoded)} for clarity. When parsing a request, it can
then check what available media types the endpoint can represent and pick
the appropriate encoder without the programming needing to write it
manually. The final GADT for specifications become as follows:

\begin{lstlisting}
  type Specification input output =
    Exact : String -> Specification (h, r) (h,r)
    QueryParam : string 
            -> (string -> Maybe a) 
            -> Specification (Maybe a -> b, r) (b, r)
    Slash : Specification (a, b) (c, d) 
            -> Specification (c, d) (h, r) 
            -> Specification (a, b) (h, r) 
    IntegerParam : Specification (int -> a, r) (a, r)
    Verb : HttpMethod -> Specification (h, r) (h, r)
    Accept : [(MediaType, r -> encoded)] -> Specification (a, encoded) (a, r)
    ContentType : [((MediaType, string -> Maybe body)]
                  -> Specification (body -> b, r) (b, r)
    Handler : StatusCode 
        -> handlerFunction 
        -> Specification (handlerFunction, noEncoder) (Result resource, resource)
        -> Specification Request (Maybe Response)
    Many :
          [Specification 
            Request (Result Response)
          ] -> Specification Request Response
\end{lstlisting}

The constructor handler now takes as a parameter a \texttt{Specification
(handlerFunction, noEncoder) (Result c, c)}, which describes that given a
handler function that correctly handles the parameter values and a
responseBuilder without an encoder, can produce a tuple of the resulting
resource as well as an encoder of that resource to the appropriate media accept
header. We enforce statically that the handlerFunction produces something which
might fail ($Result\ resource$), so that we can automatically handle that error
and throw the appropriate response. 

Notice that the Many case is for transforming many endpoints into a single one.
Also notice that Handler produces a $Specification\ Request\ (Result Response)$.
If the parsing fails we want it to return Nothing so that $Many$ has a way of
knowing if an endpoint failed to parse the request. If all endpoints fails the
yield from applying a Request to a specification interpreter should be 404 - Not
found.

From the $Specification$ GADT we can define a function $make : Specification\
Request\ Response \rightarrow Request \rightarrow Response$.  $make$ works by
evaluating the GADT to deduce how the request should be parsed.  Since
Functional programming is being used, then given a $Specification\ Request\
Response$ called $s$, we can partially apply the function $make$ to produce a
Server, since Server is \textit{type equal} to the type of $make\ s$. The full
implementation of $make$, implemented in the functional programming language
ReasonML, is available in the appendix.

% \subsection{Extracting parameters}

% The request contains a set of parameters that an endpoint expects in order for
% handler to yield a resource. These parameters need to therefore be extracted and
% applied to the handler in the right order. 

% \subsubsection{Parsing a URI}

% Each request contains a URI to the resource it wishes to access.  For instance
% \url{/api/books?author=Rowling&published=2005} wishes to access the resource
% \url{/api/books} and passes in the query parameters $author$ and $published$.
% The challenge here for the parser is that the parser should parse $/api/book$
% sequentially and ensure each part is correct. Query parameters can appears in
% any order, thus it is necessary to parse all query parameters and extract the
% ones supported by the endpoint. Thus the algorithm works as follow, given an url
% and an endpoint.

% \begin{enumerate}
    % \item Split the url at \url{?} into two strings to separate queries from the 
        % uri
    % \item Parse the URI by matching character by character
    % \item Parse the query parameters by first splitting the string into a list
        % where \url{&} occurs. Afterwards split the occurence of \url{=} within
        % that list into a tuple, if \url{=} does not exist, remove that entry as
        % it is malformatted.
% \end{enumerate}

% As each parameters get extracted they also get applied to the handler. A
% specification can be composed of many endpoints which all contain a parser for
% the request. Should one of them fail it can attempt with the next parser
% instead.

\section{Using the library}

The library exposes the GADT specification and a set of functions that can be
used to create specifications. Following is a minimalistic example of an
endpoint:\\

\noindent
\begin{math}
spec = GET \triangleright\ Path.is\ "echo" \triangleright\ Path.takeText\\
echo = endpoint\ (\lambda s \rightarrow Ok\ s)\ Ok200\ spec
\end{math}\\

$echo$ is a $Server$ which ``echoes'' back the message that is entered on the
URL \url{/echo/}, so \url{/echo/helloworld} would yield a response with the body
``helloworld''. It does this by using the function endpoint, which takes the
handler, a status code on success and a specification.  Specifications are
combined using the $(\triangleright )$ operator, which is implemented as
$(\triangleright)\ a\ b = Compose\ a\ b$.

\subsection{Defining an endpoint}

The verb of the endpoint is set by using one of the functions
\texttt{GET,POST,DELETE,PATCH}. This will make it so the endpoint only matches
those requests containing the same verb as specified.  Three operations exist
for parsing URIs which are $Uri.is : String \rightarrow Specification$,
$Uri.takeText : Specification$ and $Uri.takeInt: Specification$. $Uri.is$ parses
exactly the given string and $e = Uri.takeInt$ will parse an integer from the
path.  These can be combined so $e = Uri.is\ "api" \triangleright\ Uri.is\
"user"\ \triangleright\ Uri.takeInt$ would parse \url{api/user/5} and extract 5
as a parameter which it applies to the handler.

Accept headers can be set using the $accept$ function, which takes a list of
tuples with the first element being an encoder and the second being it's
associated content media representation. So the specification can use different
encoders depending on the accept header of the request.

Content type headers can be set using the $contentType$ function, which takes a
list of tuples with the first element being a \textit{decoder} and the second
being it's associated content media representation. This way it can check what
media representation the request content has and decode it and afterwards apply
that to the handler. 

Query parameters can be set using the $query$ function. Query takes the name of
the parameter and a decoder to use. The result of the decoder will be applied in
the handler.

\subsubsection{A get endpoint to a book API}

Using these combinator functions defined earlier, we can define a server to
access books. In this example we demonstrate how to create an endpoint that also
uses the query parameters author, specifying the name of the author of the books
we want to access; released, specifying the year we want the books to be
published; as well as how to accept multiple accept headers (json and plain):


\begin{lstlisting}
spec = 
    GET
    |> uri Path.is "api" |> Path.is "books"
    |> query "author" (\name -> Just name)
    |> query "released" intFromString
    |> accept [
         (json, Encoders.jsonList),
         (plain, Encoders.plainList),
       ]
get = endpoint getFromDatabase Ok200 spec
\end{lstlisting}

In this example, \texttt{getFromDatabase}, is deduced from the specification to
be a function with the signature \texttt{Maybe string -> Maybe int -> Result
[book]}. Encoders are functions of type \texttt{book -> encoded}. We notice how
the handler does not need to work anything with how to encode/decode books and
only needs to handle the error of failure to fetch the resource, thus separating
concerns.


\section{Conclusion}

In this chapter we have introduced the concepts of functional programming and
then from those concepts created a library that can be used to construct REST
specifications as a GADT. We have then demonstrated how a value of specification
can be used to construct REST compliant server application, I.E. we constructed
a function $make : Specification\ Request\ Response \rightarrow Request\rightarrow Response$.
