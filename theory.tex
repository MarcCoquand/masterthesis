\chapter{Theory}\label{theory} 

Based on the challenges outlined in Chapter~\ref{background}, the goal now
becomes to construct a maintainable library for REST apis. This should be done
by forcing the SOLID principles, using functional programming.  This chapter
will introduce the fundamentals of functional programming to then move on and
use that to construct a server library with automatic error handling and type
safety. In later chapters this server will then be evaluated against SOLID
principles.

\section{Concepts from Functional Programming}\label{functionalprogramming}

 While different definitions exist of what Functional programming means, here 
 functional programming is a paradigm that uses of pure functions,
 decoupling state from logic and immutable data.

\begin{description}
\item[ Purity ]

When a function is pure it means that calling a function with the same arguments
        will always return the same value and that it does not mutate any value.
        For example, given $f(x) = 2\cdot x$, then $f(2)$ will always
        return $4$. It follows then that an impure functions is either dependant
        on some state or mutates state in some way. For example, given $g(x) =
        currenttime \cdot x$, $g(5)$ will yield a different value depending on
        what time it is called. This makes it dependant on some state of the
        world. Or given $x=0$, $h()=x+1$. Then $h()$ will yield $x=1$ and $(h
        \circ h)()$ will yield $x=2$, making it impure.~\cite{wikipedia_pure}

\item[ Immutable data by deafult ]

Immutable data is data that after initialization can not change. This means if
we initialize a record, \texttt{abc = \{a: 1, b: 2, c: 3\}} then \texttt{abc.a
:= 4} is an illegal operation. Immutable data, along with purity, ensures that
no data can be mutated unless it is specifically created as mutable data.
Mutable data is an easy source of bug because it can cause two different
functions to modify the same value, leading to unexpected results.

\item[Higher-order functions]

	Higher-order functions are functions which either return a function or take
one or more functions as arguments. A function $twice : (a\rightarrow
a)\rightarrow (a\rightarrow a)$, $twice\ f = f \circ f$, takes a function as an
argument and returns a new function which performs given function twice on the
argument. 

\item[Decoupling state from logic]

Even if functional programs emphasise purity applications still need to deal
        with state somehow. For example a server would need to interact with a
        database. Functional programs solve this by separating pure functions
        and effectful functions. Effects are observable interactions with the
        environment, such as database access or printing a message.  While
        various strategies exist, like Functional Reactive
        Programming\footnote{Read more:
        \url{en.wikipedia.org/wiki/Functional_reactive_programming}},
        Dialogs\footnote{Read more:
        \url{stackoverflow.com/questions/17002119/haskell-pre-monadic-i-o}} or
        uniqueness types\footnote{Read more:
        \url{https://en.wikipedia.org/wiki/Clean_(programming_language)}}, the
        one used in Haskell (the language used in this thesis to construct the
        programs) is the IO monad. For the uninitiated, one can think of Monads
        as a way to note which functions are pure and which are effectful and
        managing the way they intermingle. It enables handling errors
        and state.\footnote{This is simplified as Monads are notoriously
        difficult to explain.}. 

As a strategy to further separate state and logic, one can construct a
        three-layered architecture, called the three layer Haskell cake. Here,
        the strategy is that one implements simple effectful functions,
        containing no logic as a base layer. Then on a second layer one
        implements an interface that implements a pure solution and one
        effectful solution. Then on the third layer one implements the logic of
        the program in pure code.  
\end{description}

So while no exact definition of Functional programming exist, this thesis
defines it as making functions pure and inheritance being based around
functionality rather than attributes. 

More advanced constructs also exists for functional programming that need to be
introduced for constructing a maintainable rest library. 

\subsection{ADTs: Sum types and product types}\label{types}

A type is in Haskell a \textit{set} of possible values that a given data can
have. This can be $int$, $char$ and custom defined types. A \textit{sum type},
\textit{Algebraic data type (ADT)} or \textit{union type} is a type which is the
sum of types, meaning that it can be one of those it's given types. For example
the type \texttt{type IntChar = Int | Char} is either an Int or a Char. A useful
application for sum types are enums such as \texttt{type Color = Red | Green |
Blue}, meaning that a value of type Color is either red, green or blue. A sum
type can be used to model data which may or may not have a value, by introducing
the Maybe type: \texttt{type Maybe value = Just value | Nothing}.A product type
is a type which is the product of types, for example \texttt{type User = User
Name Email}.  Informally, a product type can be likened to a record in
Javascript.  This allows us to model computations that might fail. For example
given $sqrt(x) = \sqrt{x},\, x\in \mathbb{Z}$ then $sqrt(-1)$ is undefined and
would cause Haskell to crash.  Instead by introducing a function
\texttt{safeSqrt}, where \texttt{safeSqrt x = if x > 0 then Just (sqrt x) else
Nothing}, the program can force the developer to handle the special case of
negative numbers. 

\subsection{GADT}\label{gadt}

a GADT is a \textit{generalized abstract data type}.  They specify, depending on
the input, what the output should be of that type. GADT enables implementing
\textit{domain-specific languages} (DSL). A DSL is a language with a limited
scope for specific applications. For example a parsing library or a calculator.

\begin{figure}[H]
    \begin{lstlisting}
data Calculator where 
  Number : Int -> Calculator Int
  Add : Calculator a -> Calculator b -> Calculator c
  Multiply : Calculator a -> Calculator b -> Calculator c
    \end{lstlisting}
    \caption{A Calculator GADT with two operations add and multiply.}
    \label{gadtcalculator}
\end{figure}

\begin{figure}[H]
    \begin{lstlisting}
mathExpression = (Number 5 `Add` Number 3) `Multiply` (Number 4 `Add` Number 3)
    \end{lstlisting}
    \caption{A mathematical expression constructed using the GADT in
    figure~\ref{gadtcalculator}}
    \label{mathexpressiongadt}
\end{figure}


Figure~\ref{gadtcalculator} defines a GADT for a calculator. The calculator can
do two operations, add and multiply. This allows us to construct mathematical
expressions. The expression in Figure~\ref{mathexpressiongadt} can translates to
$(5+3)*(4+3)$ by defining a way to evaluate the expression.
Figure~\ref{calculator} defines an evaluation for the program.

\begin{figure}[H]
    \begin{lstlisting}
evaluate :: Calculator -> Int
evaluate (Add expr1 expr2) = evaluate expr1 + evaluate expr2
evaluate (Multiply expr1 expr2) = evaluate expr1 + evaluate expr2
evaluate (Number i) = i
    \end{lstlisting}
    \caption{Evaluator for the calculator}
    \label{calculator}
\end{figure}

By separating how the expression from it's evaluation, the expression can be
reused for different purposes. For example a calculator that should for
different platforms just needs to implement different evaluators and can be sure
that logic will be the same for all platforms.

\subsection{Type classes}\label{typeclass}

A type class is a construct that allows for ad hoc polymorphism. This allows to
create constraints to type variables in parametrically polymorphic types. In
English, that means that it allows creating interfaces that must be implemented
for the types. For example the equality type class, defined in
Figure~\ref{equalitytypeclass}

\begin{figure}[H]
    \begin{lstlisting}
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
    \end{lstlisting}
    \caption{Equality type class in Haskell.}
    \label{equalitytypeclass}
\end{figure}

By defining an Equality type class one can create general functions that can be
used for anything that is ``equalable''. For example Figure~\ref{printifequal}
is a function that prints a text if two items are equal. This function can be
used for floats, ints, tuples and everything else that implements the
\texttt{Eq} type class. Other uses for type classes is Num which implements
numeric operations for floats and integers. This is useful for implementing the
MTL technique which will allow us to implement the Interpreter pattern which
will be described in the following sections.

\begin{figure}[H]
    \begin{lstlisting}
printIfEqual :: Eq a => a -> a -> IO ()
printIfEqual a b =
	if a == b then
		putStrLn "They are equal"
	else
		putStrLn "They are not equal"
    \end{lstlisting}
    \caption{A function that prints a text if the two items are equal.}
    \label{printifequal}
\end{figure}

\subsection{Functors and Contravariant Functors}

The Functor type class defines a function $map : (a\rightarrow b) \rightarrow m\
a \rightarrow m\ b$. So every type that can be mapped over is a Functor.
Examples of this are lists, where map morphs every value in the list from a to
b. Another example is for Maybe, defined in~\ref{types}. A Functor for Maybe
checks if the value is $Just\ a$, if so it morphs that value to $Just\ b$,
otherwise it returns $Nothing$. 

Not every type with a type parameter is a Functor. For example the type
$Predicate\ a = a \rightarrow Boolean$, is a function that when given some value
$a$ returns a boolean. This type can not be a Functor due to the type parameter
being the \textit{input} of the function. When the type parameter of the type is
the input, it is said to be in negative position and the type is
\textit{contravariant}.  When the type parameter is the output of a function, it
is said to be in positive position and the type is covariant. A type can be a
Functor only if it is covariant.

Contravariant Functor type class define a function $contramap : (a\rightarrow b)
\rightarrow m\ b \rightarrow m\ a$. These are useful for defining how the value
should be \textit{consumed}. So for example a $type\ encoder = a\rightarrow
encoded$, defines an encoder. The contravariant functor would allow transforming
the encoder into intermediate value.

\subsection{Brief introduction to Monads for side effects}\label{monads}

Monads\footnote{\url{en.wikipedia.org/wiki/Monad_(functional_programming)}} are
a way to sequence computations that might fail while automating away boilerplate
code. Figure~\ref{monadclass} shows how Monads are implemented as a typeclass in
Haskell. It implements the function \texttt{return}, the function bind
\texttt{(>>=)}, the function sequence \texttt{(>>)} which is bind whilst
ignoring the prior argument and \texttt{fail} which handles crashes.

\begin{figure}[H]
    \begin{lstlisting}
        class Monad m where  
            return :: a -> m a  
            (>>=) :: m a -> (a -> m b) -> m b  
            (>>) :: m a -> m b -> m b  
            fail :: String -> m a  
            fail msg = error msg 
    \end{lstlisting}
    \caption{Monad type class in Haskell.}
    \label{monadclass}
\end{figure}

Informally, Monads are as a design pattern that allows us to sequence different
computations. Without them the developer would have to explicitly check if a
computation has failed. For example, given the function $unsafeSqrtLog =
sqrt\,\circ\,log$, then $unsafeSqrtLog(-1)$ would throw an error since $log$ and
$sqrt$ are undefined for $-1$.  Section~\ref{types} showed how the \texttt{Maybe
value} type could be used to create a safe computation \texttt{safeSqrt}.  To
sequence that computation with a function \texttt{safeLog}, the user would have
to manually check that \texttt{safeSqrt} returned a value \texttt{Just result}
and not \texttt{Nothing}. Monads allows sequencing these computations without
explicitly writing this check, so composing \texttt{safeSqrt} and
\texttt{safeLog} using bind becomes \texttt{safeSqrtLog n = safeSqrt n >>=
safeLog}. The same idea applies for effectful computations such as fetching data
from a database.

\section{Functional servers}

A $server$ is a function of type $Request \rightarrow Response encoded$.
Request is a product of the path, media type, accept header, content type header
and a body. The path needs to be parsed to figure out which endpoint to use.
Based on the accept header and content type header the correct encoders and
decoders also need to be set.

Based on the REST api description outlined in chapter 2, we can define a
\textit{type specification a b} as a GADT which constructs a small DSL for a
REST api. For $specification$ there exists a function $makeServer : \forall a\
a.\ Specification\ a\ a \rightarrow (Request \rightarrow Response encoded)$.
$makeServer$ works as a parser, it extracts the parameters from the request
based on the specification and feeds them into a handler function, which is also
constructed from the specification. Specification encodes the response based on
the request's accept header and the included encoder in the specification.

The same $specification$ value can also be used afterwards to generate
documentation, client functions for generating correct requests.

\subsection{Specification as a GADT}

\subsection{Evaluation}

\theoremstyle{definition}

A verb is either get, post, put, patch or delete, represented as a sum type
$type\ Verb = Get\ |\ Post\ |\ Put\ |\ Patch\ |\
Delete$. Content types are harder to represent as a sum type due to there being
so many and are thus represented as a string instead.

\subsubsection{Request and Response}

A Request is a product type consisting of a url, queries, accept header (Media),
headers (a list of string tuples), accept media, verb, encodded body and an
encoding. The correct encoder can be deduced from the accept header.

A Response is a product type consisting of a body, status code, content type
Media, headers (a list of string tuples) and an \textit{encoder for the body}.
An encoded response instead contains an encoded body. These are separated
because the body will be constructed separately from the encoder.

\begin{lstlisting}
type Response a = {
    code: StatusCode,
    headers: Header ,
    contentType: MediaType,
    body: a -> encoded,
    encoding: Encoding.t,
};
\end{lstlisting}

A server of parameter b is a type that takes a request and transforms it into a
response of parameter b. I.E.  $server : Request\rightarrow Response\ encoded$.

Of course, depending on the Request a different Response should be returned. So
we need to introduce a $Router$ that can, depending on the request, give a
different response. 

A Router is a parser that checks the content of the request and then modifies
the response and applies the parameters of the request to a handler. We separate
how the response should be encoded from the handler to ensure inversion of
control. By making the implementation of the handler not depend on it's
environment, we make it possible to test effects (E.G. adding a resource to a
database, doing system calls) separate from the implementation of the
specification. 

In order to do so, we need to create a small language for creating
specifications. This is done by using GADTs. Recall that a GADT is a sum type
where you can specify the return types. So the GADT for a specification becomes
as follows:

\begin{lstlisting}
  type router 'input 'output =
    Top : router ('a, 'a) ('a, 'a)
    Exact : string -> router ('a, 'b) ('a, 'b)
    Custom : (string -> Maybe a) -> router ('a -> 'b, 'c) ('b, 'c)
    Query : string 
            -> (string -> Maybe 'a) 
            -> router (Maybe 'a -> 'b, 'c) ('b, 'c)
    Slash : router ('a, 'b) ('c, 'd) 
            -> router ('c, 'd) ('e, 'f) 
            -> router ('a, 'b) ('e, 'f) 
    Integer : router (int -> 'a, 'b) ('a, 'b)
    Method : HttpMethod -> router ('a, 'b) ('a, 'b)
    Accept : [(MediaType, 'b -> string)] -> router ('a, string) ('a, 'b)
    ContentType : [((MediaType, string -> Maybe 'a)]
                  -> router ('a -> 'b, 'c) ('b, 'c)
    Map : StatusCode 
        -> 'a 
        -> router ('a, string) (Result.t('c), 'c)
        -> router ('(b, string) -> string) (Result (Response.content string))
    OneOf :
          [router ('(b, string) -> string) (Result (Response.content string))]
          -> router ((b, string) -> string) Request;
\end{lstlisting}


This looks complicated, but it essentially describes the operations of a REST
api and routing. Top, Exact, Custom, Integer are used to match that URI is
correct, for example an endpoint \texttt{/user/:id} is created by doing
\texttt{Slash (Exact "user") Integer}. \texttt{Slash} connects operations
together. Afterwards \texttt{Map} is used to map a side effect to the
specification and \texttt{OneOf} is used to take a list of mapped routers and
combine them into one. The infix operator for Slash is \texttt{(>-) = Slash}. So
a valid specification can be \texttt{get = Method GET >- Exact "user" >-
Integer}.

Router is simply an \textit{instructions} for how it wants to be evaluated. That
means it can be used to generate documentation for every endpoint, by
constructing a function \texttt{document : router ((b, string) -> string)
Request -> String}, the REST API library can automatically generate the
documentation for us!

So since a Router is just instructions, we can construct \texttt{evaluate :
router((b, string) -> string) -> (Request -> Response encoded)}, I.E. the router
specification creates a server! This thesis will omit most of the details in
regards to how this is implemented. The only thing to note is that \texttt{Map}
will feed the parameters from the request into a handler $a$. This means that,
for example, a database function which fetches users will automatically not have
to, in any way, concern itself with how that user is then encoded or what status
message to return. This means that the server library \textit{forces} the user
to implement inversion of control, single responsibility principle and interface
segregation principle. It forces inversion of control, because the evaluation of
the specification is not dependent on the handler (an evaluator can just ignore
it). It forces interface segregation interface principle because the handler is
only fed the exact values, nothing more, for it to work and it can not return
more than what the specification specifies that it needs to encode the value.
Lastly it forces single responsibility principle by forcing the user to
construct a separate function for fetching the user.

