\chapter{Theory}\label{theory} 

Based on the challenges outlined in Chapter~\ref{background}, the goal now
becomes to construct a maintainable library for REST apis. The approach in this
thesis is by using constructs from Functional programming. This chapter will
introduce the fundamentals of functional programming to then move on and use
that to construct a server library with automatic error handling and type
safety.

\section{Concepts from Functional Programming}\label{functionalprogramming}

 While different definitions exist of what Functional programming means, we
 define functional programming as a paradigm that uses of pure functions,
 decoupling state from logic, using trait-based polymorphism and immutable data.

\begin{description}
\item[ Purity ]

When a function is pure it means that calling a function with the same arguments
        will always return the same value and that it does not mutate any value.
        For example, given $f(x) = 2\cdot x$, then $f(2)$ will always
        return $4$. It follows then that an impure functions is either dependant
        on some state or mutates state in some way. For example, given $g(x) =
        currenttime \cdot x$, $g(5)$ will yield a different value depending on
        what time it is called. This makes it dependant on some state of the
        world. Or given $x=0$, $h()=x+1$. Then $h()$ will yield $x=1$ and $(h
        \circ h)()$ will yield $x=2$, making it impure.~\cite{wikipedia_pure}

	\item[ Trait-based polymorphism ]

		OOP inherits classes that contain methods and
attributes.~\cite{Gamma:1995:DPE:186897} Functional programs instead
define classes that describe the actions that are possible. For example, a
class \texttt{Equality} could contain a function \texttt{isEqual} that checks
if two data types are equal. Then any data type that implements the interface
Equality, for example lists or binary trees, would be able to use the function
isEqual.  This is known as type-classes in
Haskell\footnote{\url{www.learnyouahaskell.com/types-and-typeclasses}}, mixins
in Javascript\footnote{\url{www.typescriptlang.org/docs/handbook/mixins.html}}
or traits in Scala\footnote{\url{https://docs.scala-lang.org/tour/traits.html}}.

\item[ Immutable data by deafult ]

Immutable data is data that after initialization can not change. This means if
we initialize a record, \texttt{abc = \{a: 1, b: 2, c: 3\}} then \texttt{abc.a
:= 4} is an illegal operation. Immutable data, along with purity, ensures that
no data can be mutated unless it is specifically created as mutable data.

\item[Higher-order functions]

    Higher-order functions are functions which either return a function or take
    one or more functions as arguments. A function $twice :
    (a\rightarrow a)\rightarrow (a\rightarrow a)$, $twice\ f = f \circ f$, takes
    a function as an argument and returns a new function which performs given
    function twice on the argument. So for example $addOne = (+) 1$, $addTwo =
    twice addOne$.

\item[Decoupling state from logic]

Even if functional programs emphasise purity applications still need to deal
        with state somehow. For example a server would need to interact with a
        database. Functional programs solve this by separating pure functions
        and effectful functions. Effects are observable interactions with the
        environment, such as database access or printing a message.  While
        various strategies exist, like Functional Reactive
        Programming\footnote{Read more:
        \url{en.wikipedia.org/wiki/Functional_reactive_programming}},
        Dialogs\footnote{Read more:
        \url{stackoverflow.com/questions/17002119/haskell-pre-monadic-i-o}} or
        uniqueness types\footnote{Read more:
        \url{https://en.wikipedia.org/wiki/Clean_(programming_language)}}, the
        one used in Haskell (the language used in this thesis to construct the
        programs) is the IO monad. For the uninitiated, one can think of Monads
        as a way to note which functions are pure and which are effectful and
        managing the way they intermingle. It enables handling errors
        and state.\footnote{This is simplified as Monads are notoriously
        difficult to explain.}. 

As a strategy to further separate state and logic, one can construct a
        three-layered architecture, called the three layer Haskell cake. Here,
        the strategy is that one implements simple effectful functions,
        containing no logic as a base layer. Then on a second layer one
        implements an interface that implements a pure solution and one
        effectful solution. Then on the third layer one implements the logic of
        the program in pure code. The way the second layer is implemented is
        explained further in Section~\ref{interpreterpattern}. 
\end{description}

So while no exact definition of Functional programming exist, this thesis
defines it as making functions pure and inheritance being based around
functionality rather than attributes. 

More advanced constructs also exists for functional programming that need to be
introduced in order to construct a maintainable rest api.

\subsection{ADTs: Sum types and product types}\label{types}

A type is in Haskell a \textit{set} of possible values that a given data can
have. This can be $int$, $char$ and custom defined types. A \textit{sum type} or
\textit{union type} is a type which is the sum of types, meaning that it can be
one of those it's given types. For example the type \texttt{type IntChar = Int |
Char} is either an Int or a Char. A useful application for sum types are enums
such as \texttt{type Color = Red | Green | Blue}, meaning that a value of type
Color is either red, green or blue. A sum type can be used to model data which
may or may not have a value, by introducing the Maybe type: \texttt{type Maybe
value = Just value | Nothing}.A product type is a type which is the product of
types, for example \texttt{type User = User Name Email}.  Informally, a product
type can be likened to a record in Javascript.  This allows us to model
computations that might fail. For example given $sqrt(x) = \sqrt{x},\, x\in
\mathbb{Z}$ then $sqrt(-1)$ is undefined and would cause Haskell to crash.
Instead by introducing a function \texttt{safeSqrt}, where \texttt{safeSqrt x =
if x > 0 then Just (sqrt x) else Nothing}, the program can force the developer to
handle the special case of negative numbers. Sum types are useful for
implementing the Interpreter pattern, explained in
Section~\ref{interpreterpattern}.

\subsection{GADT}\label{gadt}

a GADT is a \textit{generalized abstract data type}.  They specify, depending on
the input, what the output should be of that type. GADT enables implementing
\textit{domain-specific languages} (DSL). A DSL is a language with a limited
scope for specific applications. For example a parsing library or a calculator.

\begin{figure}[H]
    \begin{lstlisting}
        data Calculator = Number Int         
          | Add Calculator Calculator 
          | Multiply Calculator Calculator 
    \end{lstlisting}
    \caption{A Calculator GADT with two operations add and multiply.}
    \label{gadtcalculator}
\end{figure}

\begin{figure}[H]
    \begin{lstlisting}
        mathExpression = (Number 5 `Add` Number 3) `Multiply` (Number 4 `Add` Number 3)
    \end{lstlisting}
    \caption{A mathematical expression constructed using the GADT in
    figure~\ref{gadtcalculator}}
    \label{mathexpressiongadt}
\end{figure}


Figure~\ref{gadtcalculator} defines a GADT for a calculator. The calculator can
do two operations, add and multiply. This allows us to construct mathematical
expressions. The expression in Figure~\ref{mathexpressiongadt} can translates to
$(5+3)*(4+3)$ by defining a way to evaluate the expression.
Figure~\ref{calculator} defines an evaluation for the program.

\begin{figure}[H]
    \begin{lstlisting}
        evaluate :: Calculator -> Int
        evaluate (Add expr1 expr2) = evaluate expr1 + evaluate expr2
        evaluate (Multiply expr1 expr2) = evaluate expr1 + evaluate expr2
    \end{lstlisting}
    \caption{Evaluator for the calculator}
    \label{calculator}
\end{figure}

\subsection{Type classes}\label{typeclass}

A type class is a construct that allows for ad hoc polymorphism. This allows to
create constraints to type variables in parametrically polymorphic types. In
English, that means that it allows creating interfaces that must be implemented
for the types. For example the equality type class, defined in
Figure~\ref{equalitytypeclass}

\begin{figure}[H]
    \begin{lstlisting}
        class Eq a where
          (==) :: a -> a -> Bool
          (/=) :: a -> a -> Bool
    \end{lstlisting}
    \caption{Equality type class in Haskell.}
    \label{equalitytypeclass}
\end{figure}

By defining an Equality type class one can create general functions that can be
used for anything that is ``equalable''. For example Figure~\ref{printifequal}
is a function that prints a text if two items are equal. This function can be
used for floats, ints, tuples and everything else that implements the
\texttt{Eq} type class. Other uses for type classes is Num which implements
numeric operations for floats and integers. This is useful for implementing the
MTL technique which will allow us to implement the Interpreter pattern which
will be described in the following sections.

\begin{figure}[H]
    \begin{lstlisting}
        printIfEqual :: Eq a => a -> a -> IO ()
        printIfEqual a b =
            if a == b then
                putStrLn "They are equal"
            else
                putStrLn "They are not equal"
    \end{lstlisting}
    \caption{A function that prints a text if the two items are equal.}
    \label{printifequal}
\end{figure}



\subsection{Functors and Contravariant Functors}

A useful type class is the Functor type class. It defines a function 
$map : (a\rightarrow b) \rightarrow m\ a \rightarrow m\ b$. So every type that
can be mapped over is a Functor. Examples of this are lists, where map morphs
every value in the list from a to b. Another example is for Maybe, defined
in~\ref{types}. A Functor for Maybe checks if the value is $Just\ a$, if so it
morphs that value to $Just\ b$, otherwise it returns $Nothing$. 

Not every type with a type parameter is a Functor. For example the type
$Predicate = a \rightarrow Boolean$, is a function that when given some value
$a$ returns a boolean. This type can not be a Functor due to the type parameter
being the \textit{input} of the function. When the type parameter of the type is
the input, it is in negative position and the type is \textit{contravariant}.
When the type parameter is the output of a function, it is in positive position
and the type is covariant. A type can be a Functor only if it is covariant.

Contravariant Functors are type classes that define a function $contramap :
(a\rightarrow b) \rightarrow m\ b \rightarrow m\ a$. These are useful for
defining how the value should be \textit{consumed}. So for example a type
$encoder : a\rightarrow encoded$, defines an encoder. The contravariant functor
would allow transforming the encoder into intermediate value.

\subsection{Brief introduction to Monads for side effects}\label{monads}

Monads\footnote{\url{en.wikipedia.org/wiki/Monad_(functional_programming)}} are
a way to sequence computations that might fail while automating away boilerplate
code. Figure~\ref{monadclass} shows how Monads are implemented as a typeclass in
Haskell. It implements the function \texttt{return}, the function bind
\texttt{(>>=)}, the function sequence \texttt{(>>)} which is bind whilst
ignoring the prior argument and \texttt{fail} which handles crashes.

\begin{figure}[H]
    \begin{lstlisting}
        class Monad m where  
            return :: a -> m a  
            (>>=) :: m a -> (a -> m b) -> m b  
            (>>) :: m a -> m b -> m b  
            fail :: String -> m a  
            fail msg = error msg 
    \end{lstlisting}
    \caption{Monad type class in Haskell.}
    \label{monadclass}
\end{figure}

Informally, Monads are as a design pattern that allows us to sequence different
computations. Without them the developer would have to explicitly check if a
computation has failed. For example, given the function $unsafeSqrtLog =
sqrt\,\circ\,log$, then $unsafeSqrtLog(-1)$ would throw an error since $log$ and
$sqrt$ are undefined for $-1$.  Section~\ref{types} showed how the \texttt{Maybe
value} type could be used to create a safe computation \texttt{safeSqrt}.  To
sequence that computation with a function \texttt{safeLog}, the user would have
to manually check that \texttt{safeSqrt} returned a value \texttt{Just result}
and not \texttt{Nothing}. Monads allows sequencing these computations without
explicitly writing this check, so composing \texttt{safeSqrt} and
\texttt{safeLog} using bind becomes \texttt{safeSqrtLog n = safeSqrt n >>=
safeLog}. The same idea applies for effectful computations such as fetching data
from a database.

\subsection{Strong Profunctors}\label{profunctor}

Some types are both contravariant and covariant, such as the type $computation\
a\ b = a\rightarrow Result\ b$, since computation has a type parameter in positive
and negative position. A Profunctor is a type class that contains the function
$dimap : Profunctor\ p \Rightarrow (a\rightarrow b)\rightarrow (c\rightarrow d) \rightarrow p\ b\
c\rightarrow p\ a\ d$. $dimap$ both contramaps and maps the type at the same
time. So since $computation$ is both covariant and contravariant it is also a
profunctor. 

A Strong Profunctor defines two functions, $first : Profunctor\ p \Rightarrow p\ a\ b\rightarrow p\ (a,c)\
(b,c)$, $second : Profunctor\ p \Rightarrow p\ a\ b\rightarrow p\ (c,a)\ (c,b)$. This reveals the core
strength of Profunctors, to compute two separate values and then merge those
together. By defining a function $merge : Strong\ p\ \Rightarrow p\ a\ (b
\rightarrow c) \rightarrow p\ (a,b) \rightarrow c$, a Strong Profunctor gives a
``memory'' to the function, so that values can be computed both on the input and
the output of the function. How this is useful will be demonstrated in the
functional REST server chapter.

\section{SOLID principles with functional programming}\label{dependencyinjection}

To create maintainable functional programs the concepts from SOLID architecture
must be translated over to the functional paradigm where applicable. 

\subsection{Single Responsibility Principle}

A function takes a single input and produces a single output. If file structure
is centered around the morphisms of a single type. The responsibility of a file
is to morph that type into some other value. Thus it keeps the modules focused
and simple.

\subsection{Liskov Substitution Principle}

Liskov's Substitution Principle are used for reasoning about subtyping among
objects. Since objects do not exist for functional programs some translating is
needed of those concepts. The formal requirements of Liskov's Substitution
Principle are as follows:

\begin{itemize}
    \item Contravariance of method arguments should be in the subtype.
    \item Covariance of method arguments in the subtype.
    \item No new exceptions should be thrown by each subtype, except where
        those exceptions are themselves subtypes of exceptions thrown by the
        supertype.
\end{itemize}

Let's break each of these down to see how they translate in functional
programming:

\begin{description}
    \item [Contravariance of method arguments should be in the subtype.] In
        functional programming, given a type which is contravariant. In order to
        morph that into a subtype the function contramap must be used. Recall
        that $contramap : (a\rightarrow b)\rightarrow t\ b\rightarrow t\ a$. For
        a function $from\rightarrow to$ to exist $from$ must be a
        subtype of $to$! Thus this is guaranteed.
    \item [Covariance of method arguments in the subtype.] Same logic as for
        contravariance applies for covariance. In order to morph a subtype using
        map there must be a function $subtype\rightarrow type$.
    \item [No new exceptions should be thrown by each subtype, except where
        those exceptions are themselves subtypes of exceptions thrown by the
        supertype.] Since exceptions are represented by a sum type $Result$,
        described in previous chapters, it is impossible for subtypes to throw
        new exceptions.
\end{description}

\subsection{Dependency Inversion Principle} 

Dependency Inversion Principle states that the logic should not depend on it's
environment. To achieve that in functional programming the environment can
be abstracted and taken as parameters of the program. For instance given the
program readNPrint in Figure~\ref{diexample}, this program depends on the
computer IO, making it difficult to extend it to different environments, such as
databases. 

\begin{figure}[H]
    \begin{lstlisting}
        readNPrint : IO () 
        readNPrint = readLine >>= putStrLn
    \end{lstlisting}
    \caption{A program that reads input from the computer and then prints it.}
    \label{diexample}
\end{figure}

Instead, Figure~\ref{withdiexample} shows how the parameters are abstracted and
readNPrint is a higher order function instead that takes some function that
can generate a string and some function that can print a string.


\begin{figure}[H]
    \begin{lstlisting}
        readNPrint : (IO String) -> (String -> IO ()) -> IO ()
        readNPrint reader printer = reader >>= printer

        -- and then later
        consoleIO : IO ()
        consoleIO = readNPrint readLine putStrLn
    \end{lstlisting}
    \caption{A program that reads input from the computer and then prints it,
    where the logic is separated from it's environment.}
    \label{withdiexample}
\end{figure}

\subsection{Interface Segregation Principle} 

Interface Segragation Principle states that no client should be forced to depend
on methods it does not use. 

This can be enforced by the use of GADTs




