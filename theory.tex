\chapter{Theory}\label{theory} 

Based on the challenges outlined in Chapter~\ref{background}, the goal now
becomes to construct a maintainable library for REST apis. The approach in this
thesis is by using constructs from Functional programming. This chapter will
introduce the fundamentals of functional programming to then move on and use
that to construct a server library with automatic error handling and type
safety.

\section{Concepts from Functional Programming}\label{functionalprogramming}

 While different definitions exist of what Functional programming means, here 
 functional programming is a paradigm that uses of pure functions,
 decoupling state from logic and immutable data.

\begin{description}
\item[ Purity ]

When a function is pure it means that calling a function with the same arguments
        will always return the same value and that it does not mutate any value.
        For example, given $f(x) = 2\cdot x$, then $f(2)$ will always
        return $4$. It follows then that an impure functions is either dependant
        on some state or mutates state in some way. For example, given $g(x) =
        currenttime \cdot x$, $g(5)$ will yield a different value depending on
        what time it is called. This makes it dependant on some state of the
        world. Or given $x=0$, $h()=x+1$. Then $h()$ will yield $x=1$ and $(h
        \circ h)()$ will yield $x=2$, making it impure.~\cite{wikipedia_pure}

\item[ Immutable data by deafult ]

Immutable data is data that after initialization can not change. This means if
we initialize a record, \texttt{abc = \{a: 1, b: 2, c: 3\}} then \texttt{abc.a
:= 4} is an illegal operation. Immutable data, along with purity, ensures that
no data can be mutated unless it is specifically created as mutable data.
Mutable data is an easy source of bug because it can cause two different
functions to modify the same value, leading to unexpected results.

\item[Higher-order functions]

    Higher-order functions are functions which either return a function or take
    one or more functions as arguments. A function $twice :
    (a\rightarrow a)\rightarrow (a\rightarrow a)$, $twice\ f = f \circ f$, takes
    a function as an argument and returns a new function which performs given
    function twice on the argument. So for example $addOne = (+) 1$, $addTwo =
    twice addOne$.

\item[Decoupling state from logic]

Even if functional programs emphasise purity applications still need to deal
        with state somehow. For example a server would need to interact with a
        database. Functional programs solve this by separating pure functions
        and effectful functions. Effects are observable interactions with the
        environment, such as database access or printing a message.  While
        various strategies exist, like Functional Reactive
        Programming\footnote{Read more:
        \url{en.wikipedia.org/wiki/Functional_reactive_programming}},
        Dialogs\footnote{Read more:
        \url{stackoverflow.com/questions/17002119/haskell-pre-monadic-i-o}} or
        uniqueness types\footnote{Read more:
        \url{https://en.wikipedia.org/wiki/Clean_(programming_language)}}, the
        one used in Haskell (the language used in this thesis to construct the
        programs) is the IO monad. For the uninitiated, one can think of Monads
        as a way to note which functions are pure and which are effectful and
        managing the way they intermingle. It enables handling errors
        and state.\footnote{This is simplified as Monads are notoriously
        difficult to explain.}. 

As a strategy to further separate state and logic, one can construct a
        three-layered architecture, called the three layer Haskell cake. Here,
        the strategy is that one implements simple effectful functions,
        containing no logic as a base layer. Then on a second layer one
        implements an interface that implements a pure solution and one
        effectful solution. Then on the third layer one implements the logic of
        the program in pure code.  
\end{description}

So while no exact definition of Functional programming exist, this thesis
defines it as making functions pure and inheritance being based around
functionality rather than attributes. 

More advanced constructs also exists for functional programming that need to be
introduced for constructing a maintainable rest library. 

\subsection{ADTs: Sum types and product types}\label{types}

A type is in Haskell a \textit{set} of possible values that a given data can
have. This can be $int$, $char$ and custom defined types. A \textit{sum type},
\textit{Algebraic data type (ADT)} or \textit{union type} is a type which is the
sum of types, meaning that it can be one of those it's given types. For example
the type \texttt{type IntChar = Int | Char} is either an Int or a Char. A useful
application for sum types are enums such as \texttt{type Color = Red | Green |
Blue}, meaning that a value of type Color is either red, green or blue. A sum
type can be used to model data which may or may not have a value, by introducing
the Maybe type: \texttt{type Maybe value = Just value | Nothing}.A product type
is a type which is the product of types, for example \texttt{type User = User
Name Email}.  Informally, a product type can be likened to a record in
Javascript.  This allows us to model computations that might fail. For example
given $sqrt(x) = \sqrt{x},\, x\in \mathbb{Z}$ then $sqrt(-1)$ is undefined and
would cause Haskell to crash.  Instead by introducing a function
\texttt{safeSqrt}, where \texttt{safeSqrt x = if x > 0 then Just (sqrt x) else
Nothing}, the program can force the developer to handle the special case of
negative numbers. 

\subsection{GADT}\label{gadt}

a GADT is a \textit{generalized abstract data type}.  They specify, depending on
the input, what the output should be of that type. GADT enables implementing
\textit{domain-specific languages} (DSL). A DSL is a language with a limited
scope for specific applications. For example a parsing library or a calculator.

\begin{figure}[H]
    \begin{lstlisting}
        data Calculator where 
          Number : Int -> Calculator Int
          Add : Calculator a -> Calculator b -> Calculator c
          Multiply : Calculator a -> Calculator b -> Calculator c
    \end{lstlisting}
    \caption{A Calculator GADT with two operations add and multiply.}
    \label{gadtcalculator}
\end{figure}

\begin{figure}[H]
    \begin{lstlisting}
        mathExpression = (Number 5 `Add` Number 3) `Multiply` (Number 4 `Add` Number 3)
    \end{lstlisting}
    \caption{A mathematical expression constructed using the GADT in
    figure~\ref{gadtcalculator}}
    \label{mathexpressiongadt}
\end{figure}


Figure~\ref{gadtcalculator} defines a GADT for a calculator. The calculator can
do two operations, add and multiply. This allows us to construct mathematical
expressions. The expression in Figure~\ref{mathexpressiongadt} can translates to
$(5+3)*(4+3)$ by defining a way to evaluate the expression.
Figure~\ref{calculator} defines an evaluation for the program.

\begin{figure}[H]
    \begin{lstlisting}
        evaluate :: Calculator -> Int
        evaluate (Add expr1 expr2) = evaluate expr1 + evaluate expr2
        evaluate (Multiply expr1 expr2) = evaluate expr1 + evaluate expr2
        evaluate (Number i) = i
    \end{lstlisting}
    \caption{Evaluator for the calculator}
    \label{calculator}
\end{figure}

By separating how the expression from it's evaluation, the expression can be
reused for different purposes. For example a calculator that should for
different platforms just needs to implement different evaluators and can be sure
that logic will be the same for all platforms.

\subsection{Type classes}\label{typeclass}

A type class is a construct that allows for ad hoc polymorphism. This allows to
create constraints to type variables in parametrically polymorphic types. In
English, that means that it allows creating interfaces that must be implemented
for the types. For example the equality type class, defined in
Figure~\ref{equalitytypeclass}

\begin{figure}[H]
    \begin{lstlisting}
        class Eq a where
          (==) :: a -> a -> Bool
          (/=) :: a -> a -> Bool
    \end{lstlisting}
    \caption{Equality type class in Haskell.}
    \label{equalitytypeclass}
\end{figure}

By defining an Equality type class one can create general functions that can be
used for anything that is ``equalable''. For example Figure~\ref{printifequal}
is a function that prints a text if two items are equal. This function can be
used for floats, ints, tuples and everything else that implements the
\texttt{Eq} type class. Other uses for type classes is Num which implements
numeric operations for floats and integers. This is useful for implementing the
MTL technique which will allow us to implement the Interpreter pattern which
will be described in the following sections.

\begin{figure}[H]
    \begin{lstlisting}
        printIfEqual :: Eq a => a -> a -> IO ()
        printIfEqual a b =
            if a == b then
                putStrLn "They are equal"
            else
                putStrLn "They are not equal"
    \end{lstlisting}
    \caption{A function that prints a text if the two items are equal.}
    \label{printifequal}
\end{figure}

\subsection{Functors and Contravariant Functors}

The Functor type class defines a function $map : (a\rightarrow b) \rightarrow m\
a \rightarrow m\ b$. So every type that can be mapped over is a Functor.
Examples of this are lists, where map morphs every value in the list from a to
b. Another example is for Maybe, defined in~\ref{types}. A Functor for Maybe
checks if the value is $Just\ a$, if so it morphs that value to $Just\ b$,
otherwise it returns $Nothing$. 

Not every type with a type parameter is a Functor. For example the type
$Predicate\ a = a \rightarrow Boolean$, is a function that when given some value
$a$ returns a boolean. This type can not be a Functor due to the type parameter
being the \textit{input} of the function. When the type parameter of the type is
the input, it is said to be in negative position and the type is
\textit{contravariant}.  When the type parameter is the output of a function, it
is said to be in positive position and the type is covariant. A type can be a
Functor only if it is covariant.

Contravariant Functor type class define a function $contramap : (a\rightarrow b)
\rightarrow m\ b \rightarrow m\ a$. These are useful for defining how the value
should be \textit{consumed}. So for example a $type\ encoder = a\rightarrow
encoded$, defines an encoder. The contravariant functor would allow transforming
the encoder into intermediate value.

\subsection{Brief introduction to Monads for side effects}\label{monads}

Monads\footnote{\url{en.wikipedia.org/wiki/Monad_(functional_programming)}} are
a way to sequence computations that might fail while automating away boilerplate
code. Figure~\ref{monadclass} shows how Monads are implemented as a typeclass in
Haskell. It implements the function \texttt{return}, the function bind
\texttt{(>>=)}, the function sequence \texttt{(>>)} which is bind whilst
ignoring the prior argument and \texttt{fail} which handles crashes.

\begin{figure}[H]
    \begin{lstlisting}
        class Monad m where  
            return :: a -> m a  
            (>>=) :: m a -> (a -> m b) -> m b  
            (>>) :: m a -> m b -> m b  
            fail :: String -> m a  
            fail msg = error msg 
    \end{lstlisting}
    \caption{Monad type class in Haskell.}
    \label{monadclass}
\end{figure}

Informally, Monads are as a design pattern that allows us to sequence different
computations. Without them the developer would have to explicitly check if a
computation has failed. For example, given the function $unsafeSqrtLog =
sqrt\,\circ\,log$, then $unsafeSqrtLog(-1)$ would throw an error since $log$ and
$sqrt$ are undefined for $-1$.  Section~\ref{types} showed how the \texttt{Maybe
value} type could be used to create a safe computation \texttt{safeSqrt}.  To
sequence that computation with a function \texttt{safeLog}, the user would have
to manually check that \texttt{safeSqrt} returned a value \texttt{Just result}
and not \texttt{Nothing}. Monads allows sequencing these computations without
explicitly writing this check, so composing \texttt{safeSqrt} and
\texttt{safeLog} using bind becomes \texttt{safeSqrtLog n = safeSqrt n >>=
safeLog}. The same idea applies for effectful computations such as fetching data
from a database.

\section{SOLID principles with functional programming}\label{dependencyinjection}

Chapter~\ref{background} established the SOLID principles and how they can be
used as indicators to ensure that software is maintainable. SOLID is originally
used for Object-oriented programming and thus the concepts must be translated to
functional programming.

\subsection{Single Responsibility Principle}

A function takes a single input and produces a single output. If file structure
is centered around the morphisms of a single type then the responsibility of a
file is to morph that type into some other value. Thus it keeps the modules
focused and simple and would ensure that the single responsibility principle is
held. It can also be thought of as ``One function modifies one thing''.

\subsection{Liskov Substitution Principle}

Liskov's Substitution Principle states how reasoning about subtyping among
objects should be done. Since objects do not exist for functional programs some
translating is needed of those concepts. The formal requirements of Liskov's
Substitution Principle are as follows:

\begin{itemize}
    \item Contravariance of method arguments should be in the subtype.
    \item Covariance of method arguments in the subtype.
    \item No new exceptions should be thrown by each subtype, except where
        those exceptions are themselves subtypes of exceptions thrown by the
        supertype.
\end{itemize}

Let's break each of these down to see how they translate in functional
programming:

\begin{description}
    \item [Contravariance of method arguments should be in the subtype.] In
        functional programming, given a type which is contravariant. In order to
        morph that into a subtype the function contramap must be used. Recall
        that $contramap : (a\rightarrow b)\rightarrow t\ b\rightarrow t\ a$. For
        a function $from\rightarrow to$ to exist $from$ must be a
        subtype of $to$! Thus this is guaranteed.
    \item [Covariance of method arguments in the subtype.] Same logic as for
        contravariance applies for covariance. In order to morph a subtype using
        map there must be a function $subtype\rightarrow type$.
    \item [No new exceptions should be thrown] Since exceptions are represented
        by a sum type $Result$, described in previous chapters, it is impossible
        for subtypes to throw new exceptions.
\end{description}

\subsection{Dependency Inversion Principle} 

Dependency Inversion Principle states that the logic should not depend on it's
environment. To achieve that in functional programming the environment can
be abstracted and taken as parameters of the program. For instance given the
program readNPrint in Figure~\ref{diexample}, this program depends on the
computer IO, making it difficult to extend it to different environments, such as
databases. 

\begin{figure}[H]
    \begin{lstlisting}
        readNPrint : IO () 
        readNPrint = readLine >>= putStrLn
    \end{lstlisting}
    \caption{A program that reads input from the computer and then prints it.}
    \label{diexample}
\end{figure}

Instead, Figure~\ref{withdiexample} shows how the parameters are abstracted and
readNPrint is a higher order function instead that takes some function that
can generate a string and some function that can print a string.


\begin{figure}[H]
    \begin{lstlisting}
        readNPrint : (IO String) -> (String -> IO ()) -> IO ()
        readNPrint reader printer = reader >>= printer

        -- and then later
        consoleIO : IO ()
        consoleIO = readNPrint readLine putStrLn
    \end{lstlisting}
    \caption{A program that reads input from the computer and then prints it,
    where the logic is separated from it's environment.}
    \label{withdiexample}
\end{figure}

This way, the dependencies can be mocked and replaced with different ones. So if
we later want to create a $applicationIO$ we can reuse $readNPrint$ with the
functions for printing in the application and reading input from the
application.

Now for a REST api library, it means that the logic should not depend on it's
environment means that the specification of the REST api should not depend on
the server implementation. In other words, it should be trivial to port the
server logic to another runtime if needed. To do this, GADTs can be used to
separate the expression from it's evaluation. So the REST api is simply
described as instructions of a GADT. This gives other advantages such as the
ability to generate documentation for free.

\subsection{Interface Segregation Principle} 

Interface Segragation Principle states that no client should be forced to depend
on methods it does not use. This translates to, in Functional
programming, that the smallest set of data should be used for each function to
work. Recall earlier that types can be thought of as sets. Recall also that the
cardinality of a set is the amount of possible values that set can have. If the
cardinality of a type is higher than expected it allows introducing illegal
states. For example, $type\ Color = Blue | Green | Red$ has a cardinality of 3
(since it can either be Blue, Green or Red) whereas Fig.~\ref{colorcardinality}
has a cardinality of $2\cdot 2\cdot 2 = 8$ meaning that it has 5 states that are
impossible! By choosing the right data structure it lowers the amount of
possible values that are possible. So Interface Segragation Principle in
Functional programming states that a function should not be able to produce
values it does not use.

\begin{figure}[H]
    \begin{lstlisting}
        type Color = { Blue: Bool, Red: Bool, Green: Bool}
    \end{lstlisting}
    \caption{Product type Color with cardinality too high}
    \label{colorcardinality}
\end{figure}

\subsection{Open/Closed principles}

This is similar to the Dependency Injection principle in Functional programming.
Open/Closed states that a module should be open to extension, meaning you can
add new fields to the data structures it contains, or new elements to the set of
functions it performs. 








