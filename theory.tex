\chapter{Theory}\label{theory} 

Based on the challenges outlined in Chapter~\ref{background}, the goal now
becomes to construct a library for REST apis that is compliant by construction
to ensure software structural quality, introduced in Chapter~\ref{introduction}.
This chapter will introduce the fundamentals of functional programming to then
move on and use that to construct a server library which can be used to produce
REST compliant servers.

\section{Concepts from Functional Programming}\label{functionalprogramming}

 While different definitions exist of what Functional programming means, here 
 functional programming is a paradigm that uses of pure functions,
 decoupling state from logic and immutable data.(ADD\_REFERENCE)

\begin{description}
\item[ Purity ]

When a function is pure it means that calling a function with the same arguments
        will always return the same value and that it does not mutate any value.
        For example, given $f(x) = 2\cdot x$, then $f(2)$ will always
        return $4$. It follows then that an impure functions is either dependant
        on some state or mutates state in some way. For example, given $g(x) =
        currenttime \cdot x$, $g(5)$ will yield a different value depending on
        what time it is called. This makes it dependant on some state of the
        world. Or given $x=0$, $h()=x+1$. Then $h()$ will yield $x=1$ and $(h
        \circ h)()$ will yield $x=2$, making it impure.~\cite{wikipedia_pure}

\item[ Immutable data by deafult ]

Immutable data is data that after initialization can not change. This means if
we initialize a record, \texttt{abc = \{a: 1, b: 2, c: 3\}} then \texttt{abc.a
:= 4} is an illegal operation. Immutable data, along with purity, ensures that
no data can be mutated unless it is specifically created as mutable data.
Mutable data is an easy source of bug because it can cause two different
functions to modify the same value, leading to unexpected results.

\item[Higher-order functions]

	Higher-order functions are functions which either return a function or take
one or more functions as arguments. A function $twice : (a\rightarrow
a)\rightarrow (a\rightarrow a)$, $twice\ f = f \circ f$, takes a function as an
argument and returns a new function which performs given function twice on the
argument. 

\item[Partial Application] 
    It is possible in functional languages to \textit{partially apply} a
    function, meaning that we only supply some of the functions arguments, which
    yields a function instead of a value. For example, given a function $sum a b
    = a + b$, we can partially apply this function to create a function $add3 a
    = sum 3 a$. 

\item[Decoupling state from logic]

Even if functional programs emphasise purity applications still need to deal
        with state somehow. For example a server would need to interact with a
        database. Functional programs solve this by separating pure functions
        and effectful functions. Effects are observable interactions with the
        environment, such as database access or printing a message.  While
        various strategies exist, like Functional Reactive
        Programming\footnote{Read more:
        \url{en.wikipedia.org/wiki/Functional_reactive_programming}},
        Dialogs\footnote{Read more:
        \url{stackoverflow.com/questions/17002119/haskell-pre-monadic-i-o}} or
        uniqueness types\footnote{Read more:
        \url{https://en.wikipedia.org/wiki/Clean_(programming_language)}}, the
        one used in Haskell (the language used in this thesis to construct the
        programs) is the IO monad. For the uninitiated, one can think of Monads
        as a way to note which functions are pure and which are effectful and
        managing the way they intermingle. It enables handling errors
        and state.\footnote{This is simplified as Monads are notoriously
        difficult to explain.}. 

As a strategy to further separate state and logic, one can construct a
        three-layered architecture, called the three layer Haskell cake. Here,
        the strategy is that one implements simple effectful functions,
        containing no logic as a base layer. Then on a second layer one
        implements an interface that implements a pure solution and one
        effectful solution. Then on the third layer one implements the logic of
        the program in pure code.  
\end{description}

So while no exact definition of Functional programming exist, this thesis
defines it as making functions pure and inheritance being based around
functionality rather than attributes. More advanced constructs also exists for
functional programming that need to be introduced for constructing a
maintainable rest library. 

\subsection{ADTs: Sum types and product types}\label{types}

A type is in Haskell is informally a \textit{set} of possible values that a
given data can have.(ADD\_REFERENCE) This can be $int$, $char$ and custom
defined types. A \textit{sum type}, \textit{Algebraic data type (ADT)} or
\textit{union type} is a type which is the sum of types, meaning that it can be
one of those it's given types. For example the type \texttt{type IntChar = Int |
Char} is either an Int or a Char. A useful application for sum types are enums
such as \texttt{type Color = Red | Green | Blue}, meaning that a value of type
Color is either red, green or blue. A sum type can be used to model data which
may or may not have a value, by introducing the Maybe type: \texttt{type Maybe
value = Just value | Nothing}. A product type is a type which is the product of
types, for example \texttt{type User = User Name Email}.  Informally, informally
a product type is similar to an immutable record in Javascript. (ADD\_REFERENCE)
$Maybe$ allows us to model computations that might fail. For example given
$sqrt(x) = \sqrt{x},\, x\in \mathbb{Z}$ then $sqrt(-1)$ is undefined and would
cause Haskell to crash.  Instead by introducing a function \texttt{safeSqrt},
where \texttt{safeSqrt x = if x > 0 then Just (sqrt x) else Nothing}, the
program can force the developer to handle the special case of negative numbers. 

\subsection{Functors and Contravariant Functors}

A Functor have a function $map : (a\rightarrow b) \rightarrow m\ a \rightarrow
m\ b$. So every type that can be mapped over is a Functor.  Examples of this are
lists, where map morphs every value in the list from a to b. Another example is
for Maybe, defined in~\ref{types}. A Functor for Maybe checks if the value is
$Just\ a$, if so it morphs that value to $Just\ b$, otherwise it returns
$Nothing$. 

Not every type with a type parameter is a Functor. For example the type
$Predicate\ a = a \rightarrow Boolean$, is a function that when given some value
$a$ returns a boolean. This type can not be a Functor due to the type parameter
being the \textit{input} of the function. When the type parameter of the type is
the input, it is said to be in negative position and the type is
\textit{contravariant}.  When the type parameter is the output of a function, it
is said to be in positive position and the type is covariant. A type can be a
Functor only if it is covariant.

Contravariant Functors have a function $contramap : (a\rightarrow b) \rightarrow
m\ b \rightarrow m\ a$. (ADD\_REFERENCE contravariacn) These are useful for
defining how the value should be \textit{consumed}. So for example a $type\
encoder = a\rightarrow encoded$, defines an encoder. The contravariant functor
would allow transforming the encoder into intermediate value.

\subsection{Domain-specific languages}

A domain specific language (DSL) is a programming language made for a specific
domain.(ADD\_REFERENCE DSL) Typical examples of DSLs are HTML for designing web
pages and SQL for making database calls. An eDSL is such a language embedded
within the syntax of the language.(ADD\_REFERENCE edsl) EDSLs are useful due to
the ability to separate the evaluation of the logic of the program to the logic
itself. In the case of REST apis, this means we can develop an eDSL which can
interpret REST apis and use them for different purposes. 

\subsection{Generalized algebraic data type}\label{gadt}

One method for constructing eDSLs in functional programming is through the use
of \textit{generalized algebraic data type} (GADT).(ADD\_REFERENCE GADT)  They
specify, depending on the input, what the output should be of that type. GADT
enables implementing \textit{domain-specific languages} (DSL) and ensure
that values of the DSL are statically correct. 

\begin{figure}[H]
    \begin{lstlisting}
type Calculator 
    Number : Int  -> Calculator Int
    Bool : Bool -> Calculator Bool
    Add : Calculator Int -> Calculator Int -> Calculator Int
    Multiply : Calculator Int -> Calculator Int -> Calculator Int
    Equal : Calculator a -> Calculator a -> Calculator Bool
    \end{lstlisting}
    \caption{A Calculator GADT with three operations add, eq and multiply.}
    \label{gadtcalculator}
\end{figure}

\begin{figure}[H]
    \begin{lstlisting}
mathExpression = (Number 5 `Add` Number 3) `Multiply` (Number 4 `Add` Number 3)
    \end{lstlisting}
    \caption{A mathematical expression constructed using the GADT in
    figure~\ref{gadtcalculator}}
    \label{mathexpressiongadt}
\end{figure}


Figure~\ref{gadtcalculator} demonstrates a minimal example GADT for a
calculator. The calculator has five constructors: $Number$, $Bool$, $Equal$
$Add$ and $Multiply$. From this we can construct mathematical expressions and
ensure that they are correct by constructions, or else they will not compile.
If we attempt to construct an expression $Add\ (Bool\ False)\ (Number\ 5)$ the
compilation will fail as $Multiply$ expects a number or an expression. However
only having the expression is not very useful without some way of evaluating it.
In Figure~\ref{calculator} we demonstrate how we can evaluate the expression
using pattern matching.

\begin{figure}[H]
    \begin{lstlisting}
evaluate : forall a. Calculator a -> Int
evaluate (Add expr1 expr2) = evaluate expr1 + evaluate expr2
evaluate (Multiply expr1 expr2) = evaluate expr1 + evaluate expr2
evaluate (Equal expr1 expr2) = (evaluate expr1) == (evaluate expr2)
evaluate (Number i) = i
evaluate (Bool b) = b
    \end{lstlisting}
    \caption{Evaluator for the calculator}
    \label{calculator}
\end{figure}

Another example of GADTs is the creation of type safe lists, where we can be
sure statically that performing $head$ will yield an answer. This is
demonstrated in Figure~\ref{safelist}

\begin{figure}[H]
    \begin{lstlisting}
type Empty
type NonEmpty

type SafeList a b =
     Nil : SafeList a Empty
     Cons : a -> SafeList a b -> SafeList a NonEmpty

safeHead : SafeList a NonEmpty -> a
safeHead (Cons x _) = x
    \end{lstlisting}
    \caption{Type safe list}
    \label{safelist}
\end{figure}

By separating how the expression from it's evaluation, the expression can be
reused for different purposes. For instance it would be possible to use the same
logic for the calculators and implement them for different platforms and ensure
statically that all platforms follow the same logic. So GADTs are useful for
creating expressions that can later on be evaluated.  Since the logic is
separated from the evaluation and correct by construction it means that we only
need to test the evaluator, which can be done using property-based testing
(ADD\_REFERENCE testing the hard stuff John hughes). Testing the logic means
checking that it's equal to it's intended value, which requires manual review.

\section{Servers using GADTs: Router}\label{router}

Using GADTs, we can construct a statically correct eDSL for server
routers.(ADD\_REFERENCE code from
https://github.com/elm/package.elm-lang.org/blob/master/src/backend/Server/Router.hs)
A server router parses incoming requests and extracts query parameters and
parameters and executes a function depending on the result. We first define a
minimal example of a GADT $Router$, in Figure~\ref{routergadtminimal}.  The two
constructors $Top$ and $Exact$ describe matching \url{/} or for a given string
$s$, \url{/s} respectively. It should also be possible to link two $Router$
together to allow us to match nested urls. Thus the constructor $Compose$ allows
composing routers together composed of multiple parts.  For instance the url
\url{/hello/world} corresponds to $Compose\ (Exact\ "hello")\ (Exact\ "world")$.

\begin{figure}[H]
    \begin{lstlisting}
type Router 
    Top : Router 
    Exact : String -> Router 
    Compose : Router -> Router -> Router
    \end{lstlisting}
    \caption{Minimal router GADT}
    \label{routergadtminimal}
\end{figure}


Definition in Figure~\ref{routergadtminimal} is not sufficient for a route
parser as a route can also contain parameters, such as integers for id or
strings. These parameters need to be applied to a function which can handle
them. GADTs can also be used to also describe the transformation of the handler
function's arguments, by extending Router with two parameters. In
Figure~\ref{extendedrouter} we extend the router with the constructors Integer,
String and add two parameters input and output. The Integer and String
constructors describe the application of an argument to a function. Together
with $Compose$, an api for a user resource could be implemented as
\texttt{Compose (Compose (Exact "user") String) Integer}, which could be
interpreted to match on urls formatted as \url{/users/:string/:int} where
\url{:string} is a valid string and \url{:int} is a valid int. These parameters
get applied to the handler, thus the type of becomes \texttt{Router (String ->
Int -> a) a}. Informally the type can be read as give me a function which takes
a String and an Int and I will give you $a$.

\begin{figure}[H]
    \begin{lstlisting}
type Router start result 
    Top : Router start result
    Exact : String -> Router start result
    Integer : Router (Int -> result) result
    String : Router (String -> result) result
    Compose : Router a b -> Router b c -> Router a c
    \end{lstlisting}
    \caption{Router GADT extended with Int and string}
    \label{extendedrouter}
\end{figure}

So $Router$ describes a specification for what the type signature of the handler
must be and what it must then produce. Finally there needs to be a way to apply
that handler to the arguments so that it can produce that value, so we add a
constructor to $Router$, \texttt{Produce : function -> Router function output ->
Router (output -> c) c}. So the final GADT for the router eDSL becomes the one
in Figure~\ref{finalrouter}. \texttt{Router (output -> c) c} informally
translates to ``give me something that can transform the output to c and I will
give you c''.

\begin{figure}[H]
    \begin{lstlisting}
type Router start result 
    Top : Router start result
    Exact : String -> Router start result
    Integer : Router (Int -> result) result
    String : Router (String -> result) result
    Compose : Router a b -> Router b c -> Router a c
    Produce : function -> Router function output -> Router (output -> c) c
    \end{lstlisting}
    \caption{Router GADT extended with Int and string}
    \label{finalrouter}
\end{figure}

This section has demonstrated how GADTs are useful for constructing a eDSL for
routers. What was not described is how to interpret the router which is omitted
for brevity. However the source code for the final solution can be found in
Appendix. Furthermore we will extend this functionality to implement all of the
functionality of a REST server.

% \subsection{Type classes}\label{typeclass}

% A type class is a construct that allows for ad hoc polymorphism. This allows to
% create constraints to type variables in parametrically polymorphic types. In
% English, that means that it allows creating interfaces that must be implemented
% for the types. For example the equality type class, defined in
% Figure~\ref{equalitytypeclass}

% \begin{figure}[H]
    % \begin{lstlisting}
% class Eq a where
  % (==) :: a -> a -> Bool
  % (/=) :: a -> a -> Bool
    % \end{lstlisting}
    % \caption{Equality type class in Haskell.}
    % \label{equalitytypeclass}
% \end{figure}

% By defining an Equality type class one can create general functions that can be
% used for anything that is ``equalable''. For example Figure~\ref{printifequal}
% is a function that prints a text if two items are equal. This function can be
% used for floats, ints, tuples and everything else that implements the
% \texttt{Eq} type class. Other uses for type classes is Num which implements
% numeric operations for floats and integers. This is useful for implementing the
% MTL technique which will allow us to implement the Interpreter pattern which
% will be described in the following sections.

% \begin{figure}[H]
    % \begin{lstlisting}
% printIfEqual :: Eq a => a -> a -> IO ()
% printIfEqual a b =
	% if a == b then
		% putStrLn "They are equal"
	% else
		% putStrLn "They are not equal"
    % \end{lstlisting}
    % \caption{A function that prints a text if the two items are equal.}
    % \label{printifequal}
% \end{figure}

% \subsection{Brief introduction to Monads for side effects}\label{monads}

% Monads\footnote{\url{en.wikipedia.org/wiki/Monad_(functional_programming)}} are
% a way to sequence computations that might fail while automating away boilerplate
% code. Figure~\ref{monadclass} shows how Monads are implemented as a typeclass in
% Haskell. It implements the function \texttt{return}, the function bind
% \texttt{(>>=)}, the function sequence \texttt{(>>)} which is bind whilst
% ignoring the prior argument and \texttt{fail} which handles crashes.

% \begin{figure}[H]
    % \begin{lstlisting}
        % class Monad m where  
            % return :: a -> m a  
            % (>>=) :: m a -> (a -> m b) -> m b  
            % (>>) :: m a -> m b -> m b  
            % fail :: String -> m a  
            % fail msg = error msg 
    % \end{lstlisting}
    % \caption{Monad type class in Haskell.}
    % \label{monadclass}
% \end{figure}

% Informally, Monads are as a design pattern that allows us to sequence different
% computations. Without them the developer would have to explicitly check if a
% computation has failed. For example, given the function $unsafeSqrtLog =
% sqrt\,\circ\,log$, then $unsafeSqrtLog(-1)$ would throw an error since $log$ and
% $sqrt$ are undefined for $-1$.  Section~\ref{types} showed how the \texttt{Maybe
% value} type could be used to create a safe computation \texttt{safeSqrt}.  To
% sequence that computation with a function \texttt{safeLog}, the user would have
% to manually check that \texttt{safeSqrt} returned a value \texttt{Just result}
% and not \texttt{Nothing}. Monads allows sequencing these computations without
% explicitly writing this check, so composing \texttt{safeSqrt} and
% \texttt{safeLog} using bind becomes \texttt{safeSqrtLog n = safeSqrt n >>=
% safeLog}. The same idea applies for effectful computations such as fetching data
% from a database.

\section{Functional servers}

A $Server$ is a type function $Request \rightarrow Response$. Simply, given some
Request it should produce some Response where Request is a product of the url,
media type, accept header, content type header and a body.  The Response is a
product of status code, a set of headers where headers are a tuple of strings, a
content type and an encoding. If the Response returns a successful code in the
range of 2XX, 3XX we say it is a successful response. The goal is to ensure that
values of $Server$ are following the REST API specifications.  Thus we want to
define a function $make$ that can construct a value of $Server$ which follow
REST specifications.

Based on the REST api description outlined in chapter 2, we define a type
$Specification\ input\ output$, which is a GADT for specifying how to transform
input into output. We define $Specification\ Request\ Response$ to mean a
\textit{server specification}, since it defines how to turn a $Request$ (input)
into a $Response$ (output). $Specification$ works as DSL for one or more
\textit{endpoints} within a REST api where an endpoint composed of parts, where
each part is one or more of the following:

\begin{itemize}
    \item A correct URI to access the resource, such as \url{api/user:int}.
        While the final implementations support any type, this implementation
        will only support integers and strings for brevity.
    \item Unlike the router defined in Section~\ref{router}, query parameters
        also need to be supported.
    \item A set of content types that it can represent the resources.
    \item A set of content type representations for the resource that request can
        submit which can be parsed by the server.
    \item A map of the query parameter name and their respective parser,
        where parser is a function of type $string \rightarrow Maybe\ a$)
    \item An HTTP verb
    \item Status code on success
    \item A function, called a handler, which takes some parameters and returns
        either the resource or a failure message and failure code. This is used
        for side effects, for instance database access. We model the result as
        a sum type $Result\ a = Ok\ a\ |\ Fail\ Message\ Code$.
\end{itemize}

An endpoint specification is defined as $Specification\ Request\ (Maybe\
Response)$, as it might fail to produce a response if it fails to parse the url.
A difference from the $Router$ in Section~\ref{router} is that parts need to
produce \textit{two} intermediate values.  One value is the handler and another
value is how to encode the result of the handler. We define the encoder as
ResponseBuilder, which is a contravariant of type $a -> encoded$.  Thus we
modify the constructors, \texttt{Exact : String -> Specification input output}
becomes \texttt{Exact : String -> Specification (handler, responseBuilder)
(handler, responseBuilder)}. The constructor \texttt{Integer} gets modified to
\texttt{Integer : Specification (int -> a, r) (a, r)}. The full GADT gets shown
below.

We introduce a few new constructor, one being \texttt{Accept} which takes a list
of encoders and their corresponding accept header (\texttt{(Mediatype, [r ->
encoded])}) and produces a \texttt{Specification (a, encoded) (a, r)},
with responsebuilder's definition expanded it produces \texttt{Specification
(a, encoded) (a, r -> encoded)}. When parsing a request, it can
then check what available media types the endpoint can represent and pick
the appropriate encoder without the programming needing to write it
manually. The final GADT for specifications become as follows:

\begin{lstlisting}
  type Specification input output =
    Exact : String -> Specification (h, r) (h,r)
    QueryParam : string 
            -> (string -> Maybe a) 
            -> Specification (Maybe a -> b, r) (b, r)
    Slash : Specification (a, b) (c, d) 
            -> Specification (c, d) (h, r) 
            -> Specification (a, b) (h, r) 
    IntegerParam : Specification (int -> a, r) (a, r)
    Verb : HttpMethod -> Specification (h, r) (h, r)
    Accept : [(MediaType, r -> encoded)] -> Specification (a, encoded) (a, r)
    -- Attempt to extract body and apply it to the handler.
    ContentType : [((MediaType, string -> Maybe body)]
                  -> Specification (body -> b, r) (b, r)
    Handler : StatusCode 
        -> handlerFunction 
        -> Specification (handlerFunction, noEncoder) (Result resource, resource)
        -> Specification Request (Maybe Response)
    Many :
          [Specification 
            Request (Result Response)
          ] -> Specification Request Response
\end{lstlisting}

The constructor $handler$ now takes as a parameter a \texttt{Specification
(handlerFunction, noEncoder) (Result c, c)}, which describes that given a
handler function that correctly handles the parameter values and a
responseBuilder without an encoder, can produce a tuple of the resulting
resource as well as an encoder of that resource to the appropriate media accept
header. We enforce statically that the handlerFunction produces something which
might fail ($Result\ resource$), so that we can automatically handle that error
and throw the appropriate response. 

The $Many$ constructor is for transforming multiple endpoints into a single one.
Also notice that Handler produces a $Specification\ Request\ (Result Response)$.
If the parsing fails we want it to return Nothing so that $Many$ has a way of
knowing if an endpoint failed to parse the request. If all endpoints return
$Nothing$ then the specification interpreter should return a response with  404
- Not found.

From the $Specification$ GADT we can define a function\\ $make : Specification\
Request\ Response \rightarrow (Request \rightarrow Response) \sim\\
Specification\ Request\ Response \rightarrow Server$ ($a\sim b$ means $a$ is
type equal to $b$).  $make$ works by evaluating the GADT to deduce how the
request should be parsed and how to produce a REST compliant response from that
request.  The full implementation of $make$, implemented in the functional
programming language ReasonML, available in the appendix.

% \subsection{Extracting parameters}

% The request contains a set of parameters that an endpoint expects in order for
% handler to yield a resource. These parameters need to therefore be extracted and
% applied to the handler in the right order. 

% \subsubsection{Parsing a URI}

% Each request contains a URI to the resource it wishes to access.  For instance
% \url{/api/books?author=Rowling&published=2005} wishes to access the resource
% \url{/api/books} and passes in the query parameters $author$ and $published$.
% The challenge here for the parser is that the parser should parse $/api/book$
% sequentially and ensure each part is correct. Query parameters can appears in
% any order, thus it is necessary to parse all query parameters and extract the
% ones supported by the endpoint. Thus the algorithm works as follow, given an url
% and an endpoint.

% \begin{enumerate}
    % \item Split the url at \url{?} into two strings to separate queries from the 
        % uri
    % \item Parse the URI by matching character by character
    % \item Parse the query parameters by first splitting the string into a list
        % where \url{&} occurs. Afterwards split the occurence of \url{=} within
        % that list into a tuple, if \url{=} does not exist, remove that entry as
        % it is malformatted.
% \end{enumerate}

% As each parameters get extracted they also get applied to the handler. A
% specification can be composed of many endpoints which all contain a parser for
% the request. Should one of them fail it can attempt with the next parser
% instead.

\section{Using the library}

The library exposes a set of functions that can be used to create
specifications, which all make use of $specification$. Following is a
minimalistic example of an endpoint:\\

\noindent
\begin{math}
spec = GET \triangleright\ Path.is\ "echo" \triangleright\ Path.takeText\\
echo = endpoint\ (\lambda s \rightarrow Ok\ s)\ Ok200\ spec
\end{math}\\

$echo$ is a $Server$ which ``echoes'' back the message that is entered on the
URL \url{/echo/}, so \url{/echo/helloworld} would yield a response with the body
``helloworld''. It does this by using the function endpoint, which takes the
handler, a status code on success and a specification.  Specifications are
combined using the $(\triangleright )$ operator, which is implemented as
$(\triangleright)\ a\ b = Compose\ a\ b$.

\subsection{Defining an endpoint}

The verb of the endpoint is set by using one of the functions
\texttt{GET,POST,DELETE,PATCH}. This will make it so the endpoint only matches
those requests containing the same verb as specified.  Three operations exist
for parsing URIs which are $Uri.is : String \rightarrow Specification$,
$Uri.takeText : Specification$ and $Uri.takeInt: Specification$. $Uri.is$ parses
exactly the given string and $e = Uri.takeInt$ will parse an integer from the
path.  These can be combined so $e = Uri.is\ "api" \triangleright\ Uri.is\
"user"\ \triangleright\ Uri.takeInt$ would parse \url{api/user/5} and extract 5
as a parameter which it applies to the handler.

Accept headers can be set using the $accept$ function, which takes a list of
tuples with the first element being an encoder and the second being it's
associated content media representation. So the specification can use different
encoders depending on the accept header of the request.

Content type headers can be set using the $contentType$ function, which takes a
list of tuples with the first element being a \textit{decoder} and the second
being it's associated content media representation. This way it can check what
media representation the request content has and decode it and afterwards apply
that to the handler. 

Query parameters can be set using the $query$ function. Query takes the name of
the parameter and a decoder to use. The result of the decoder will be applied in
the handler.

\subsubsection{A get endpoint to a book API}

Using these combinator functions defined earlier, we can define a server to
access books. In this example we demonstrate how to create an endpoint that also
uses the query parameters author, specifying the name of the author of the books
we want to access; released, specifying the year we want the books to be
published; as well as how to accept multiple accept headers (json and plain):


\begin{lstlisting}
spec = 
    GET
    |> uri Path.is "api" |> Path.is "books"
    |> query "author" (\name -> Just name)
    |> query "released" intFromString
    |> accept [
         (json, Encoders.jsonList),
         (plain, Encoders.plainList),
       ]
get = endpoint getFromDatabase Ok200 spec
\end{lstlisting}

In this example, \texttt{getFromDatabase}, is deduced from the specification to
be a function with the signature \texttt{Maybe string -> Maybe int -> Result
[book]} and if successful returns a status code 200. Encoders are functions of
type \texttt{book -> encoded}. 

\section{Conclusion}

In this chapter we have introduced the concepts of functional programming and
then from those concepts created a GADT that can be used to construct REST
specifications. The implementation afterwards to make it REST compliant can then
after be found in Appendix (ADD\_REFERENCE). We have then demonstrated how a
value of specification can be used to construct REST compliant server
application, I.E. we constructed a higher order function $make : Specification\
Request\ Response \rightarrow (Request\rightarrow Response)$.
