\chapter{Theory}\label{theory} 

With our research question now defined, the goal is to construct a library for
REST APIs that is compliant by construction to ensure software functional
quality. This chapter will introduce the fundamentals of functional programming
to then move on and use that to construct a server library which can be used to
produce REST compliant servers. The SOLID guidelines that
Chapter~\ref{background} introduced were originally written for Object-oriented
programming, so this chapter will also introduce SOLID principles but for
functional programming. 

\section{Concepts from Functional Programming}\label{functionalprogramming}

 While different definitions exist of what Functional programming means, here 
 functional programming is a paradigm that uses of pure functions,
 decoupling the state from logic and immutable data.~\cite{hughes1989functional}

\begin{description}
\item[ Purity ]

When a function is pure it means that calling a function with the same arguments
        will always return the same value and that it does not mutate any value.
        For example, given $f(x) = 2\cdot x$, then $f(2)$ will always
        return $4$. It follows then that an impure functions is either dependant
        on some state or mutates state in some way. For example, given $g(x) =
        currenttime \cdot x$, $g(5)$ will yield a different value depending on
        what time it is called. This makes it dependant on some state of the
        world. Or given $x=0$, $h()=x+1$. Then $h()$ will yield $x=1$ and $(h
        \circ h)()$ will yield $x=2$, making it impure.~\cite{hughes1989functional}

\item[ Immutable data by default ]

Immutable data is data that after initialization can not change. This means that
an initialized record, for example, \texttt{abc = \{a: 1, b: 2, c: 3\}} then
\texttt{abc.a := 4} is an illegal operation. Immutable data, along with purity,
ensures that no data can be mutated unless it is specifically created as mutable
data.  Mutable data is an easy source of bug because it can cause two different
functions to modify the same value, leading to unexpected results.

\item[Higher-order functions]

	Higher-order functions are functions which either return a function or take
one or more functions as arguments. A function $twice : (a\rightarrow
a)\rightarrow (a\rightarrow a)$, $twice\ f = f \circ f$, takes a function as an
argument and returns a new function which performs given function twice on the
argument. 

\item[Partial Application] 
    It is possible in functional languages to \textit{partially apply} a
    function, meaning that only some of the function's arguments are supplied,
    which yields a function instead of a value. For example, given a function
    $sum a b = a + b$, a partially applied function is $add3 a = sum 3 a$. 

\item[Decoupling state from logic]

Even if functional programs emphasize purity applications still need to deal
        with state somehow. For example, a server would need to interact with a
        database. Functional programs solve this by separating pure functions
        and effectful functions. Effects are observable interactions with the
        environment, such as database access or printing a message.  While
        various strategies exist, like Functional Reactive
        Programming\footnote{Read more:
        \url{en.wikipedia.org/wiki/Functional_reactive_programming}},
        Dialogs\footnote{Read more:
        \url{stackoverflow.com/questions/17002119/haskell-pre-monadic-i-o}} or
        uniqueness types\footnote{Read more:
        \url{https://en.wikipedia.org/wiki/Clean_(programming_language)}}, the
        one used in Haskell (the language used in this thesis to construct the
        programs) is the IO monad. For the uninitiated, one can think of Monads
        as a way to note which functions are pure and which are effectful and
        managing the way they intermingle. It enables handling errors
        and state.\footnote{This is simplified as Monads are notoriously
        difficult to explain.}.  As a strategy to further separate state and logic, one can construct a
three-layered architecture called the three-layer Haskell
cake.~\cite{parsonsmatt} Here,
        the strategy is that one implements simple effectful functions,
        containing no logic as a base layer. Then on a second layer, one
        implements an interface that implements a pure solution and one
        effectful solution. Then on the third layer, one implements the logic of
        the program in pure code.  
\end{description}

So while no exact definition of Functional programming exists, this thesis
defines it as making functions pure and inheritance being based around
functionality rather than attributes. More advanced constructs also exist for
functional programming that needs to be introduced for constructing a
maintainable rest library. 

\subsection{ADTs: Sum types and product types}\label{types}

A type is in Haskell is informally a \textit{set} of possible values that a
given data can have.~\cite{evantypesassets} This can be $int$, $char$ and
custom-defined types. A \textit{sum type}, \textit{Algebraic data type (ADT)}
or \textit{union type} is a type which is the sum of types, meaning that it can
be one of those its given types. For example the type \texttt{type IntChar =
Int | Char} is either an Int or a Char. A useful application for sum types are
enums such as \texttt{type Color = Red | Green | Blue}, meaning that a value of
type Color is either red, green or blue. A sum type can be used to model data
which may or may not have a value, by introducing the Maybe type: \texttt{type
Maybe value = Just value | Nothing}. A product type is a type which is the
product of types, for example, \texttt{type User = User Name Email}.
Informally, a product type is similar to an immutable record in Javascript.
$Maybe$ allows us to model computations that might fail. For example given
$sqrt(x) = \sqrt{x},\, x\in \mathbb{Z}$ then $sqrt(-1)$ is undefined and would
cause Haskell to crash.  Instead by introducing a function \texttt{safeSqrt},
where \texttt{safeSqrt x = if x > 0 then Just (sqrt x) else Nothing}, the
program can force the developer to handle the special case of negative numbers. 

\subsection{Functors and Contravariant Functors}

A Functor have a function $map : (a\rightarrow b) \rightarrow m\ a \rightarrow
m\ b$. So every type that can be mapped over is a Functor.  Examples of this are
lists, where map morphs every value in the list from a to b. Another example is
for Maybe, defined in~\ref{types}. A Functor for Maybe checks if the value is
$Just\ a$, if so it morphs that value to $Just\ b$, otherwise it returns
$Nothing$. 

Not every type with a type parameter is a Functor. For example the type
$Predicate\ a = a \rightarrow Boolean$, is a function that when given some value
$a$ returns a boolean. This type can not be a Functor due to the type parameter
being the \textit{input} of the function. When the type parameter of the type is
the input, it is said to be in negative position and the type is
\textit{contravariant}.  When the type parameter is the output of a function, it
is said to be in positive position and the type is covariant. A type can be a
Functor only if it is covariant.

Contravariant Functors have a function $contramap : (a\rightarrow b) \rightarrow
m\ b \rightarrow m\ a$.~\cite{bancerek2001miscellaneous} These are useful for
defining how the value should be \textit{consumed}. For example, a $type\
encoder = a\rightarrow encoded$, defines an encoder. The contravariant functor
would allow transforming the encoder into intermediate value.

\subsection{Domain-specific languages}

A domain-specific language (DSL) is a programming language made for a specific
domain.~\cite{elic2007systematic} Typical examples of DSLs are HTML for
designing web pages and SQL for making database calls. An EDSL is such a
language embedded within the syntax of the language.~\cite{hudak1996building}
EDSLs are useful due to the ability to separate the evaluation of the logic of
the program to the logic itself. In the case of REST APIs, an EDSL can be
developed which can interpret REST APIs and use them for different purposes. 

\subsection{Generalized algebraic data type}\label{gadt}

One method for constructing EDSLs in functional programming is through the use
of \textit{generalized algebraic data type} (GADT).~\cite{cheney2003first}
They specify, depending on the input, what the output should be of that type.
GADT enables implementing \textit{domain-specific languages} (DSL) and ensure
that values of the DSL are statically correct. 

\begin{figure}[H]
    \begin{lstlisting}
type Calculator 
    Number : Int  -> Calculator Int
    Bool : Bool -> Calculator Bool
    Add : Calculator Int -> Calculator Int -> Calculator Int
    Multiply : Calculator Int -> Calculator Int -> Calculator Int
    Equal : Calculator a -> Calculator a -> Calculator Bool
    \end{lstlisting}
    \caption{A Calculator GADT with three operations add, eq and multiply.}
    \label{gadtcalculator}
\end{figure}

\begin{figure}[H]
    \begin{lstlisting}
mathExpression = (Number 5 `Add` Number 3) `Multiply` (Number 4 `Add` Number 3)
    \end{lstlisting}
    \caption{A mathematical expression constructed using the GADT in
    figure~\ref{gadtcalculator}}
    \label{mathexpressiongadt}
\end{figure}


Figure~\ref{gadtcalculator} demonstrates a minimal example of GADT for a
calculator. The calculator has five constructors: $Number$, $Bool$, $Equal$
$Add$ and $Multiply$. This can be used to construct mathematical expressions and
ensure that they are correct by constructions, or else they will not compile.
Attempting to construct an expression $Add\ (Bool\ False)\ (Number\ 5)$ will
lead to the compilation failing as $Multiply$ expects a number or an expression.
However, only having the expression is not very useful without some way of
evaluating it.  Figure~\ref{calculator} demonstrates how evaluating the
expression using pattern matching is done.

\begin{figure}[H]
    \begin{lstlisting}
evaluate : forall a. Calculator a -> Int
evaluate (Add expr1 expr2) = evaluate expr1 + evaluate expr2
evaluate (Multiply expr1 expr2) = evaluate expr1 + evaluate expr2
evaluate (Equal expr1 expr2) = (evaluate expr1) == (evaluate expr2)
evaluate (Number i) = i
evaluate (Bool b) = b
    \end{lstlisting}
    \caption{Evaluator for the calculator}
    \label{calculator}
\end{figure}

Another example of GADTs is the creation of type-safe lists, where the list can
be proved statically that performing $head$ will yield an answer. This is
demonstrated in Figure~\ref{safelist}

\begin{figure}[H]
    \begin{lstlisting}
type Empty
type NonEmpty

type SafeList a b =
     Nil : SafeList a Empty
     Cons : a -> SafeList a b -> SafeList a NonEmpty

safeHead : SafeList a NonEmpty -> a
safeHead (Cons x _) = x
    \end{lstlisting}
    \caption{Type safe list}
    \label{safelist}
\end{figure}

By separating how the expression from its evaluation, the expression can be
reused for different purposes. For instance, it would be possible to use the
same logic for the calculators and implement them for different platforms and
ensure statically that all platforms follow the same logic. So GADTs are useful
for creating expressions that can, later on, be evaluated.  Since the logic is
separated from the evaluation and correct by construction it means that only the
evaluator needs to be tested, which can be done using property-based testing
.~\cite{hughes2016experiences} Testing the logic means
checking that its equal to its intended value, which requires manual review.

\section{Servers using GADTs: Router}\label{router}

GADTs can be used to construct a statically correct EDSL for server
routers.~\cite{evanrouter} A server router parses incoming requests and
extracts query parameters and parameters and executes a function depending on
the result. Figure~\ref{routergadtminimal} defines a minimal example of a GADT
$Router$.  The two constructors $Top$ and $Exact$ describe matching \url{/} or
for a given string $s$, \url{/s} respectively. It should also be possible to
link two $Router$ together to allow us to match nested URLs. Thus the
constructor $Compose$ allows composing routers together composed of multiple
parts.  For instance the URL \url{/hello/world} corresponds to $Compose\
(Exact\ "hello")\ (Exact\ "world")$.

\begin{figure}[H]
    \begin{lstlisting}
type Router 
    Top : Router 
    Exact : String -> Router 
    Compose : Router -> Router -> Router
    \end{lstlisting}
    \caption{Minimal router GADT}
    \label{routergadtminimal}
\end{figure}


Definition in Figure~\ref{routergadtminimal} is not sufficient for a route
parser as a route can also contain parameters, such as integers for id or
strings. These parameters need to be applied to a function which can handle
them. GADTs can also be used to also describe the transformation of the handler
function's arguments, by extending Router with two parameters.
Figure~\ref{extendedrouter} extends the router with the constructors Integer,
String and add two parameters input and output. The Integer and String
constructors describe the application of an argument to a function. Together
with $Compose$, an API for a user resource could be implemented as
\texttt{Compose (Compose (Exact "user") String) Integer}, which could be
interpreted to match on URLs formatted as \url{/users/:string/:int} where
\url{:string} is a valid string and \url{:int} is a valid int. These parameters
get applied to the handler, thus the type of becomes \texttt{Router (String ->
Int -> a) a}. Informally the type can be read as to give me a function which
takes a String and an Int and I will give you $a$.

\begin{figure}[H]
    \begin{lstlisting}
type Router start result 
    Top : Router start result
    Exact : String -> Router start result
    Integer : Router (Int -> result) result
    String : Router (String -> result) result
    Compose : Router a b -> Router b c -> Router a c
    \end{lstlisting}
    \caption{Router GADT extended with Int and string}
    \label{extendedrouter}
\end{figure}

So $Router$ describes a specification for what the type signature of the handler
must be and what it must then produce. Finally, there needs to be a way to apply
that handler to the arguments so that it can produce that value, which is done
by adding a constructor to $Router$, \texttt{Produce : function -> Router
function output -> Router (output -> c) c}. So the final GADT for the router
eDSL becomes the one in Figure~\ref{finalrouter}. \texttt{Router (output -> c)
c} informally translates to ``give me something that can transform the output to
c and I will give you c''.

\begin{figure}[H]
    \begin{lstlisting}
type Router start result 
    Top : Router start result
    Exact : String -> Router start result
    Integer : Router (Int -> result) result
    String : Router (String -> result) result
    Compose : Router a b -> Router b c -> Router a c
    Produce : function -> Router function output -> Router (output -> c) c
    \end{lstlisting}
    \caption{Router GADT extended with Int and string}
    \label{finalrouter}
\end{figure}

This section has demonstrated how GADTs are useful for constructing an EDSL for
routers. What was not described is how to interpret the router which is omitted
for brevity. The source code for the final solution can be found in Appendix.
Next section will extend this functionality to implement all of the
functionality of a REST server.

\section{Functional servers}

A $Server$ is a type function $Request \rightarrow Response$. Simply, given some
Request it should produce some Response where Request is a product of the URL,
media type, accept header, content-type header and a body.  The Response is a
product of status code, a set of headers where headers are a tuple of strings, a
content-type, and an encoding. If the Response returns a successful code in the
range of 2XX, 3XX it is a successful response. The goal is to ensure that values
of $Server$ are following the REST API specifications.  This is done by defining
a function $make$ that can construct a value of $Server$ which follow REST
specifications.

Let $Specification\ input\ output$, be defined as a GADT for specifying how to
transform input into output, based on the REST API description outlined in
chapter 2.  $Specification\ Request\ Response$ informally is a \textit{server
specification}, since it defines how to turn a $Request$ (input) into a
$Response$ (output). $Specification$ works as DSL for one or more
\textit{endpoints} within a REST API where an endpoint composed of parts, where
each part is one or more of the following:

\begin{itemize}
    \item A correct URI to access the resource, such as \url{api/user:int}.
        While the final implementations support any type, this implementation
        will only support integers and strings for brevity.
    \item Unlike the router defined in Section~\ref{router}, query parameters
        also need to be supported.
    \item A set of content types that it can represent the resources.
    \item A set of content type representations for the resource that request can
        submit which can be parsed by the server.
    \item A map of the query parameter name and their respective parser,
        where parser is a function of type $string \rightarrow Maybe\ a$)
    \item An HTTP verb
    \item Status code on success
    \item A function called a handler, which takes some parameters and returns
        either the resource or a failure message and failure code. This is used
        for side effects, for instance, database access. The result is modeled as
        a sum type $Result\ a = Ok\ a\ |\ Fail\ Message\ Code$.
\end{itemize}

An endpoint specification is defined as $Specification\ Request\ (Maybe\
Response)$, as it might fail to produce a response if it fails to parse the url.
A difference from the $Router$ in Section~\ref{router} is that parts need to
produce \textit{two} intermediate values.  One value is the handler and another
value is how to encode the result of the handler. The encoder is defined as
ResponseBuilder , which is a contravariant of type $a -> encoded$.  With this
new change, the constructor \texttt{Exact : String -> Specification input
output} now becomes \texttt{Exact : String -> Specification (handler,
responseBuilder) (handler, responseBuilder)}. The constructor \texttt{Integer}
gets modified to \texttt{Integer : Specification (int -> a, r) (a, r)}. The full
GADT gets shown below.

A few other new constructors are introduced, one being \texttt{Accept} which
takes a list of encoders and their corresponding accept header
(\texttt{(Mediatype, [r -> encoded])}) and produces a \texttt{Specification (a,
    encoded) (a, r)}, with responsebuilder's definition expanded it produces
    \texttt{Specification (a, encoded) (a, r -> encoded)}. When parsing a
    request, it can then check what available media types the endpoint can
    represent and pick the appropriate encoder without the programming needing
    to write it manually. The final GADT for specifications become as follows:

\begin{lstlisting}
  type Specification input output =
    Exact : String -> Specification (h, r) (h,r)
    QueryParam : string 
            -> (string -> Maybe a) 
            -> Specification (Maybe a -> b, r) (b, r)
    Slash : Specification (a, b) (c, d) 
            -> Specification (c, d) (h, r) 
            -> Specification (a, b) (h, r) 
    IntegerParam : Specification (int -> a, r) (a, r)
    Verb : HttpMethod -> Specification (h, r) (h, r)
    Accept : [(MediaType, r -> encoded)] -> Specification (a, encoded) (a, r)
    -- Attempt to extract body and apply it to the handler.
    ContentType : [((MediaType, string -> Maybe body)]
                  -> Specification (body -> b, r) (b, r)
    Handler : StatusCode 
        -> handlerFunction 
        -> Specification (handlerFunction, noEncoder) (Result resource, resource)
        -> Specification Request (Maybe Response)
    Many :
          [Specification 
            Request (Result Response)
          ] -> Specification Request Response
\end{lstlisting}

The constructor $handler$ now takes as a parameter a \texttt{Specification
(handlerFunction, noEncoder) (Result c, c)}, which describes that given a
handler function that correctly handles the parameter values and a
responseBuilder without an encoder can produce a tuple of the resulting
resource, as well as an encoder of that resource to the appropriate media,
accept header. $Specification$ enforce statically that the handlerFunction
produces something which might fail ($Result\ resource$), so that the library
can automatically handle that error and throw the appropriate response. 

The $Many$ constructor is for transforming multiple endpoints into a single one.
Also notice that Handler produces a $Specification\ Request\ (Result Response)$.
If the parsing fails it returns Nothing so that $Many$ has a way of knowing if
an endpoint failed to parse the request. If all endpoints return $Nothing$ then
the specification interpreter should return a response with  404 - Not found.

The $Specification$ GADT allows defining a function\\ $make : Specification\
Request\ Response \rightarrow (Request \rightarrow Response) \sim\\
Specification\ Request\ Response \rightarrow Server$ ($a\sim b$ means $a$ is
type equal to $b$).  $make$ works by evaluating the GADT to deduce how the
request should be parsed and how to produce a REST compliant response from that
request.  The full implementation of $make$, implemented in the functional
programming language ReasonML, available in the appendix.

\section{Using the library}

The library exposes a set of functions that can be used to create
specifications, which all make use of $specification$. Following is a
minimalistic example of an endpoint:\\

\noindent
\begin{math}
spec = GET \triangleright\ Path.is\ "echo" \triangleright\ Path.takeText\\
echo = endpoint\ (\lambda s \rightarrow Ok\ s)\ Ok200\ spec
\end{math}\\

$echo$ is a $Server$ which ``echoes'' back the message that is entered on the
URL \url{/echo/}, so \url{/echo/helloworld} would yield a response with the body
``helloworld''. It does this by using the function endpoint, which takes the
handler, a status code on success and a specification.  Specifications are
combined using the $(\triangleright )$ operator, which is implemented as
$(\triangleright)\ a\ b = Compose\ a\ b$.

\subsection{Defining an endpoint}

The verb of the endpoint is set by using one of the functions
\texttt{GET,POST,DELETE,PATCH}. This will make it so the endpoint only matches
those requests containing the same verb as specified.  Three operations exist
for parsing URIs which are $Uri.is : String \rightarrow Specification$,
$Uri.takeText : Specification$ and $Uri.takeInt: Specification$. $Uri.is$ parses
exactly the given string and $e = Uri.takeInt$ will parse an integer from the
path.  These can be combined so $e = Uri.is\ "api" \triangleright\ Uri.is\
"user"\ \triangleright\ Uri.takeInt$ would parse \url{api/user/5} and extract 5
as a parameter which it applies to the handler.

Accept headers can be set using the $accept$ function, which takes a list of
tuples with the first element being an encoder and the second being its
associated content media representation. So the specification can use different
encoders depending on the accept header of the request.

Content-type headers can be set using the $contentType$ function, which takes a
list of tuples with the first element being a \textit{decoder} and the second
being its associated content media representation. This way it can check what
media representation the request's content has and decode it and afterward apply
that to the handler. 

Query parameters can be set using the $query$ function. Query takes the name of
the parameter and a decoder to use. The result of the decoder will be applied in
the handler.

\subsubsection{Example: A get endpoint to a book API}

Using these combinator functions defined earlier, it is possible to define a
server to access books. This example demonstrates how to create an endpoint that
uses the query parameters author, specifying the name of the author of the
books to access; released, specifying the year the fetched books should be
published; as well as how to accept multiple accept headers (JSON and plain):


\begin{lstlisting}
spec = 
    GET
    |> uri Path.is "api" |> Path.is "books"
    |> query "author" (\name -> Just name)
    |> query "released" intFromString
    |> accept [
         (json, Encoders.jsonList),
         (plain, Encoders.plainList),
       ]
get = endpoint getFromDatabase Ok200 spec
\end{lstlisting}

In this example, \texttt{getFromDatabase}, is deduced from the specification to
be a function with the signature \texttt{Maybe string -> Maybe int -> Result
[book]} and if successful returns a status code 200. Encoders are functions of
type \texttt{book -> encoded}. 

\section{SOLID principles in Functional programming}\label{dependencyinjection}

To evaluate the library from a standpoint of testability, error-proneness and
extendability using SOLID principles are introduced work for functional
programming. In the following sections, the five parts of SOLID principles have
been translated to an equivalent for functional programming.

\subsection{Single Responsibility Principle}

A function takes a single input and produces a single output. If file structure
is centered around the morphisms of a single type then the responsibility of a
file is to morph that type into some other value. Thus it keeps the modules
focused and simple. It can also be thought of as ``One function modifies one
thing''. So in summary, a program follows the Single Responsibility Principle if 

\begin{enumerate}
    \item Each function performs only a morphism, which is guaranteed if the
        function is pure.
    \item The file does not contain functions that do not have a type signature
        using any of the types declared within that file. This rule has
        an exception for functions that are only used by the other functions
        within that module (called a helper functions). Helper functions can be
        merged into the function that uses it but they are split for
        readability purposes.
\end{enumerate}

\subsection{Liskov Substitution Principle}

Liskov's Substitution Principle states how reasoning about subtyping among
objects should be done. If S is a subtype of T, then the subtype relation means
that any term S can be safely used in a context where type T is expected. Since
subtypes do not exist in classic functional programming some translation is
needed. The formal requirements of Liskov's Substitution Principle are as
follows:

\begin{itemize}
    \item Contravariance of method arguments should be in the subtype.
    \item Covariance of method arguments in the subtype.
    \item No new exceptions should be thrown by each subtype, except where
        those exceptions are themselves subtypes of exceptions thrown by the
        supertype.
\end{itemize}

In functional programming, the Liskov Substitution Principle is simply
Contravariant Functors.  To comply with the principle, argument types overriding
a method must be contravariant and the reverse should be true for the return
type, it should be covariant.  A contravariant type can only be overridden by
using $contramap$ and its result is in positive position hence its covariant.
This principle does not apply to the application evaluated later.

\subsection{Dependency Inversion Principle} 

Dependency Inversion Principle states that the logic should not depend on its
environment. To achieve that in functional programming the environment can
be abstracted and taken as parameters of the program. For instance, given the
program readNPrint in Figure~\ref{diexample}, this program depends on the
computer IO, making it difficult to extend it to different environments, such as
databases. 

\begin{figure}[H]
    \begin{lstlisting}
readNPrint : IO () 
readNPrint = readLine >>= putStrLn
    \end{lstlisting}
    \caption{A program that reads input from the computer and then prints it.}
    \label{diexample}
\end{figure}

Instead, Figure~\ref{withdiexample} shows how the parameters are abstracted and
readNPrint is a higher-order function instead that takes some function that
can generate a string and some function that can print a string.


\begin{figure}[H]
    \begin{lstlisting}
readNPrint : (IO String) -> (String -> IO ()) -> IO ()
readNPrint reader printer = reader >>= printer

-- and then later
consoleIO : IO ()
consoleIO = readNPrint readLine putStrLn
    \end{lstlisting}
    \caption{A program that reads input from the computer and then prints it,
    where the logic is separated from its environment.}
    \label{withdiexample}
\end{figure}

This way, the dependencies can be mocked and replaced with different ones. So 
 to create an $applicationIO$,  $readNPrint$ can be reused with the
functions for printing in the application and reading input from the
application.  For a REST API library, it means that the logic should not depend
on its environment means that the specification of the REST API should not
depend on the server implementation. In other words, it should be trivial to
port the server logic to another runtime if needed. To do this, GADTs can be
used to separate the expression from its evaluation. So the REST API is simply
described as instructions of a GADT. 

\subsection{Interface Segregation Principle} 

Interface Segragation Principle states that no client should be forced to depend
on methods it does not use. This translates to, in Functional programming, that
the smallest set of data should be used for each function to work. Recall
earlier that types can be thought of as sets. Recall also that the cardinality
of a set is the amount of possible values that set can have. If the cardinality
of a type is higher than expected it allows introducing illegal states. 

\begin{figure}[H]
    \begin{lstlisting}
type Color = { Blue: Bool, Red: Bool, Green: Bool}
    \end{lstlisting}
    \caption{Product type Color with cardinality too high}
    \label{colorcardinality}
\end{figure}


For example, $type\ Color = Blue | Green | Red$ has a cardinality of 3 (since it
can either be Blue, Green or Red) whereas Fig.~\ref{colorcardinality} has a
cardinality of $2\cdot 2\cdot 2 = 8$ meaning that it has fives states that are
impossible. By choosing the right data structure it lowers the amount of
possible values that are possible. So Interface Segragation Principle in
Functional programming states that a function should not be able to produce
values it does not use.

\begin{figure}[H]
    \begin{lstlisting}
data IUserRepo =  {
	getUser : Id -> IO User,
	storeUser : User -> Id -> IO ()
}

-- Later on
getUserEndpoint : IUserRepo -> Request -> Response
-- ...
    \end{lstlisting}
    \caption{Normal interface for operations}
    \label{twomanyoperations}
\end{figure}


Another example, observe that in Fig~\ref{twomanyoperations}, the type
\texttt{IUserRepo} has two operations. \texttt{getUserEndpoint} is a function
meant to get a user from a database, thus it does not need to store anything.
However as it takes $IUserRepo$ as an argument, the function is capable of
producing more values than it should. This breaks the Interface segregation
principle. So in summary, adherence to the interface segregation principle means
that the cardinality of the types is minimized.

\subsection{Open/Closed principles}\label{openclosed}

Open/Closed principle states that software entities (classes, modules,
functions, etc.) should be open for extension, but closed for modification. OCP
is advice on how to write modules in a way that encourages backward
compatibility and so that if extra functionality is needed, the modifier does
not need to look at the class to make modifications. So if a class has some new
requirements you do not need to modify the source code but can instead extend
the superclass.

When this principle is applied to Functional programming, it can roughly be
seen as the same as the expression problem. The expression problem states that
\textit{``The goal is to define a datatype by cases, where one can add new cases
    to the datatype and new functions over the datatype, without recompiling
existing code and while retaining static type safety (e.g., no casts).''}
~\cite{torgersen2004expression}

The similarity with expression problem and OCP is that you want to be able to
extend the program (add new cases to the datatype) without recompiling existing
code.  Object-oriented programming uses classes that should be open for
extension and closed for modification. In functional programming, new cases to
datatype should be possible and new functions. OCP exists because modifying code
in production might cause regressions. Thus a preferable solution is to extend
the previous code instead.


\section{Summary}

This chapter introduced the concepts of functional programming and then from
those concepts created a GADT that can be used to construct REST
specifications.  This chapter then demonstrated how a value of specification
can be used to construct REST compliant server application, I.E. a higher-order
function $make : Specification\ Request\ Response \rightarrow
(Request\rightarrow Response)$ was constructed. The interpreter can be found in
Appendix~\ref{cause}. This chapter also established the guidelines for
evaluating functional programs adherence to SOLID principles, which were
originally introduced for Object-oriented programs.  The library created can
construct a functionally correct server which can be used to evaluate the
software structural quality of functional programming by comparing it to an
imperative version. 
